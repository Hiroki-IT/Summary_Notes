# 01. MVCとは

ドメイン駆動設計が考案される以前、MVCの考え方が主流であった。

![MVCモデル](https://user-images.githubusercontent.com/42175286/57635646-8838e700-75e2-11e9-837d-253c006b7725.png)



### ◇ MVCからドメイン駆動設計への発展

しかし、特にModelの役割が抽象的過ぎたため、開発規模が大きくなるにつれて、Modelに役割を集中させ過ぎてしまうことがあった。それから、ドメイン駆動設計が登場したことによって、MVCは発展し、M・V・Cそれぞれの役割がより具体的で精密になった。



# 02. ドメイン駆動設計とは

### ◇ドメインエキスパートとユビキタス言語

ドメインエキスパート（現実世界の業務内容に詳しく、また実際にシステムを使う人）と、エンジニアが話し合いながら、設計していく。設計の時、ドメインエキスパートとエンジニアの話し合いに齟齬が生まれぬように、ユビキタス言語（業務内容について共通の用語）を設定しておく。



### ◇ 戦略的設計

1. ドメインエキスパートと話し合い、現実世界の業務内容に含まれる『名詞』と『振舞』に着目。
2. 『名詞』と『振舞』を要素として、EntityやValueObjectを設計。
3. 設計されたEntityやValueObjectを用いて、ドメインモデリング（オブジェクト間の関連付け）を行う。



### ◇ 戦術的設計

戦略的設計を基に、各オブジェクトとオブジェクト間の関連性を実装していく。

![DDDの概念](https://user-images.githubusercontent.com/42175286/61179612-d305c800-a640-11e9-8c4a-3d31225af633.jpg)



### ◇ ドメイン駆動設計の派生型

現在までに、ドメイン駆動設計の派生型がいくつか提唱されている。

- **Layered architecture**

- **Hexagonal architecture**

- **Onion architecture**

  

# 03. Layered architecture 型ドメイン駆動設計

### ◇ 責務の分担方法

![ドメイン駆動設計](https://user-images.githubusercontent.com/42175286/58724663-2ec11c80-8418-11e9-96e9-bfc6848e9374.png)

レイヤードアーキテクチャ型ドメイン駆動設計において、MVCは、以下の4層に再編成できる。

- **User Interface層**
- **Application層**
- **Domain層（ビジネロジックをコード化）**
- **Infrastructure層（データベースとマッピング）**



# 04. Dependency Inversion Principle（依存性逆転の原則）

### ◇ DIPとは

1. 上位のモジュールは、下位のモジュールに依存してはならない。どちらのモジュールも『抽象』に依存すべきである。
2. 『抽象』は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである。



### ◇ DIPに基づくドメイン駆動設計

Repositoryの抽象クラスは、ドメイン層に配置する。そして、Repositoryの実装クラスはInfrastructure層に配置する。抽象クラスで抽象メソッドを記述することによって、実装クラスでの実装が強制される。つまり、実装クラスは抽象クラスに依存している。依存性逆転の原則に基づくことによって、ドメイン層への影響なく、Repositoryの交換が可能。

![ドメイン駆動設計_逆転依存性の原則](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_依存性逆転の原則.jpg)



# 05. Entity

### ◇ Entityとは

![ドメイン駆動設計_エンティティ](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_エンティティ.jpg)

（ユビキタス言語の例）顧客、注文など

1. 状態を変化させる必要があるプロパティをもつ。
2. オブジェクトにアイデンティティがあり、他のオブジェクトと同じ属性をもっていても、区別する必要がある。 

**【実装例】**

```
class DogToyEntity
{
	# おもちゃ種別VO
	private $toyType;
	
	# おもちゃ商品名
	private $toyName;
	
	# 数量
	private $number;
	
	# 価格Entity
	private $priceEntity;
	
	# 色VO
	private $colorVO;
	
	
	# Setterを実装
	public function __construct
	(
		$toyType,
		$toyName,
		$number,
		$priceVO,
		$colorVO
	)
	{
		$this->toyType = $toyType,
		$this->toyName = $toyName,
		$this->number = $number,
		$this->priceEntity = $priceEntity,
		$this->colorVO = $colorVO
	}
	
	
	# 自身と下位VOを用いて、集約を構成
	public static function aggregateDogToyEntity($fetchedData)
	{
		return new DogToyEntity
		(
			new ColorVO($fetchedData['dog_toy_type']),
			$fetchedData['dog_toy_name'],
			$fetchedData['number'],
			new PriceVO($fetchedData['dog_toy_price']),
			new ColorVO($fetchedData['color_value'])
		);
	}		

	
	# Getterを実装
	public function toyNameWithColor()
	{
		if($this->toyName && $this->colorVO->colorName())
		return sprintf('%s（%s）', $this->toyName, $this->colorVO->colorName())
	}
	
}
```

### ◇ RouteEntityとは

  EntityやValueObjectからなる集約の中で、最終的にアプリケーション層へレスポンスされる集約を、『RouteEntity』という。

![ドメイン駆動設計_集約関係](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_集約関係.jpg)

**【実装例】**

```
class ToyOrderEntity
{
	# 犬用おもちゃ
	private $dogToyEntity;
	
	# 猫用おもちゃ
	private $catToyEntity;
	
	# Setterを実装
	public function __construct
	(
		$dogToyEntity,
		$catToyEntity
	)
	{
		$this->dogToyEntity = $dogToyEntity;
		$this->catToyEntity = $catToyEntity;
	}
	
	# 自身と下位Entityを用いて、『RouteEntity』の集約を構成
	public static function aggregateToyOrderEntity($fetchedData)
	{
		return new toyOrderEntity
		(
			DogToyEntity::aggregateDogToyEntity($fetchedData),
			CatToyEntity::aggregateCatToyEntity($fetchedData)
		);
	} 
	
}	
```





# 06. ValueObject

![ドメイン駆動設計_バリューオブジェクト](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_バリューオブジェクト.jpg)

### ◇ （1）ドメイン層の計測、定量化、説明

ドメイン層に関する値（金額、数字、日付、氏名、色など）の、計測、定量化、説明を行い、その結果をプロパティに持つ。



### ◇ （2）プロパティの不変性

生成されたインスタンスのプロパティは変更されない。

### ◇ （3）概念的な統一体

### ◇ （4）オブジェクトの交換可能性

オブジェクトが新しくインスタンス化された場合、以前に同一オブジェクトから生成されたインスタンスは置き換えられる。

### ◇ （5）オブジェクト間の等価性

全てのプロパティの値が他のVOと同じ場合、同一のVOと見なされる。 

### ◇ （6）メソッドによってオブジェクトの状態が変わらない



**【実装例1】**

Immutableトレイトを基に、VOを生成する。

```
// （1）ドメイン層の氏名を扱うVO
class Name
{
   // （2）Immutabトレイトを用いて、プロパティの不変性を実現
    use \Preset\Immutable;

    // 苗字プロパティ
    private $lastName;
    
    // 名前プロパティ
    private $firstName;
    
    // （6） メソッドによってオブジェクトの状態が変わらない
    public function fullName()
    {
    	return $this->lastName . $this->firstName;
    }
    
    // 
    protected static function computedPropertyNames()
    {
        return [
            'fullName'
        ];
    }
}
```



**【実装例2】**

同様に、Immutableトレイトを基に、VOを生成する。

```
// ドメイン層の金額を扱うVO
class Money
{

}
```



# 07. TypeCodeObject

### ◇ TypeCodeObjectとは

区分や種類の値を扱ったオブジェクトは、TypeCodeObjectと呼ばれ、VOまたはEnumによって実装する。

### ◇ EnumによるTypeCodeObjectの実装

**【実装例1】**

```
class ColorVO extends Enum
{
	const RED = '1'
	const BLUE = '2'

	# 『self::定数名』で、定義の値へアクセスする。
	private $defs = [
		self::RED => ['colorname' => 'レッド'];
		self::BLUE => ['colorname' => 'ブルー'];
	];

	# 色値プロパティ
	private $colorValue
	
	# 色名プロパティ。
	private $colorName;
	
	
	# インスタンス化の時に、『色の区分値』を受け取る。
	public function __construct(string $value)
	{
		# $kbnValueに応じて、色名をcolornameプロパティにセットする。
		$this->colorValue = $value;
		$this->colorname = $this->defs[$value]['colorName'];
	}
    
    
    # constructによってセットされた色値を返すメソッド。
	public function colorValue() :int
	{
		return $this->colorValue;
	} 


	# constructによってセットされた色名を返すメソッド。
	public function colorName() :string
	{
		return $this->colorName;
	} 
	
}
```



# 08. Id

- **実装例**





# 09. Service

他の３区分に分類できないもの（例：Id-Aを生成するId-B）。



# 10. Repository

### ◇ Repositoryとは

構成したい集約とRepositoryは、一対一の関係になる。例えば、OrderのRouteEntityからなる集約を構成するRepositoryは、OrderRepositoryと名付ける。



### ◇ 抽象クラス

DIPに基づくドメイン駆動設計の場合、Repositoryの抽象クラスを配置する。

![ドメイン駆動設計_逆転依存性の原則](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_依存性逆転の原則.jpg)



### ◇ 集約構成とデータ挿入

1. アプリケーション層から集約がリクエストされる。
2. ファクトリの呼び出しによって、EntityやValueObjectから構成される集約を生成
3. データベースに追加する。

![ドメイン駆動設計_リポジトリ_データ更新](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_リポジトリ_データ更新.png)

### ◇ データ取得と集約再構成

1. データベースからデータを取得。
2. ファクトリの呼び出しによって、EntityやValueObjectから構成される集約を加工し、再構成する。
3. 再構成された集約をアプリケーション層にレスポンス。

![ドメイン駆動設計_リポジトリ_データ取得](C:\Projects\summary_notes\SummaryNotes\Image\ドメイン駆動設計_リポジトリ_データ取得.jpg)

**【実装例】**

```
class ToyOrderRepository
{

	# データベースからデータを取得
	public function fetchDataSet()
	{
		$select = [
			'dog_toy.type AS dog_toy_type',
			'dog_toy.name AS dog_toy_name',
			'dog_toy.number AS number',
			'dog_toy.price AS dog_toy_price,
			'color.color_value AS color_value'
		];
		$query = $this->getFecthQuery($select);return $query->getConnection()->executeQuery()->fetchAll(); 
	}
	
	
	# 『RouteEntity』の配列をアプリケーション層へレスポンス
	public function arrayedToyOrderEntities()
	{	
		$toyOrderEntities = [];
		foreach($this->fetchDataSet() as $fetchedData){
			$toyOrderEntities[] = ToyOrderEntity::aggregateToyOrderEntity($fetchedData)
		}
		return $toyOrderEntities;
	}
	
}
```



# 11. Factory

### ◇ Factoryとは

責務として、構成した集約関係を加工して新sたな集約を再構成する。

- **実装例**

```
class Factory
{
	#
	private $factory


	#
	public function __construct(Factory $factory)
	{
		$this->$factory = $factory
	}
	
	
	# 
	public function ToyInstance()
	{
		isset($this->factory){
			//なんらかの集約処理;
		}
	}
}
```



# 12. Controller

責務として、ドメイン層の抽象メソッドを用いて、Use case（使用事例）を実装する。

（例）オンラインショッピングにおけるUse case

![ユースケース図](C:\Projects\summary_notes\SummaryNotes\Image\ユースケース図.png)