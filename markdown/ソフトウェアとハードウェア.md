# 01-01. ソフトウェアの具体例

### ◆ OSS：Open Source Softwareとは

以下の条件を満たすソフトウェアをOSSと呼ぶ。

1. 利用者は、無償あるいは有償で自由に再配布できる。

2. 利用者は、ソースコードを入手できる。

3. 利用者は、コードを自由に変更できる。また、変更後に提供する場合、異なるライセンスを追加できる。

4. 差分情報の配布を認める場合には、同一性の保持を要求してもかまわない。 ⇒ よくわからない

5. 提供者は、特定の個人やグループを差別できない。

6. 提供者は、特定の分野を差別できない。

7. 提供者は、全く同じOSSの再配布において、ライセンスを追加できない。

8. 提供者は、特定の製品でのみ有効なライセンスを追加できない。

9. 提供者は、他のソフトウェアを制限するライセンスを追加できない。

10. 提供者は、技術的に偏りのあるライセンスを追加できない。

    

### ◆ OSSの具体例

![OSS一覧](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/OSS一覧.png)

引用：https://openstandia.jp/oss_info/

- **OS**

  CentOS、Linux、Unix、Ubuntu

- **データベース**

  MySQL、MariaDB

- **プログラミング言語**

  言うまでもない。

- **フレームワーク**

  言うまでもない。

- **OR Mapper**

  言うまでもない。

- **バージョン管理**

  Git、Subversion

- **Webサーバ**

  Apache

- **業務システム**

  Redmine

- **インフラ構築**

  Chef、Puppet

- **クラウド構築**

  Docker



### ◆ Linux Distribution（Linuxの種類）

現在、Linuxは3つを源流として、いくつもの派生系へ分岐している。

- **RedHat系**

RedHat、CentOS、Fedora

- **Debian系**

Debian、Ubuntu、

- **Slackware系**

Slackware

![Linux distribution](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Linux distribution.png)



# 01-02. ソフトウェアについて

### ◆ ユーザの操作が、命令としてハードウェアに伝わるまで

ソフトウェアには、応用ソフトウェアとシステムソフトウェアがある。

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### ◆ 応用ソフトウェア

**【具体例】**

その辺のアプリ



### ◆ Middleware

**【具体例】**

- **Webサーバソフトウェア（Apache、Nginx）をもつWebサーバ**
- **APサーバソフトウェア（Apache内蔵、NGINX Unit）をもつAPサーバ**
- **DBサーバをもつデータベース管理システム**

※詳しくは、ネットワークのノートを参照せよ。



### ◆ 基本ソフトウェア（広義のOS）

![基本ソフトウェアの構成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/基本ソフトウェアの構成.png)

- **制御プログラム（：別名カーネル）**

  **【具体例】**

  カーネル、マイクロカーネル、モノリシックカーネル

- **言語プロセッサ**

  **【具体例】**

  アセンブラ、コンパイラ、インタプリタというプログラム

- **サービスプログラム**

  **【具体例】**

  ファイル圧縮プログラム



### ◆ Firmware



### ◆ デバイスドライバ



# 01-03. 基本ソフトウェアの汎用言語プログラム

### ◆ ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### ◆ 基本ソフトウェア（再掲）

![基本ソフトウェアの構成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/基本ソフトウェアの構成.png)



### ◆ コンパイラ型言語とインタプリタ型言語の種類

コンパイラというプログラムによって翻訳される言語をコンパイラ型言語、インタプリタというプログラムによって翻訳される言語をインタプリタ型言語という。プログラム言語（ウェブサイトならJava、php、Javascriptなど）は、機械語に変換された後、CPUによって読み込まれる。そして、ハードウェア（ウェブサイトならパソコン）のCPUによって、ソースコードに書かれた様々な処理が実行される。

![コンパイル型とインタプリタ型言語](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/コンパイル型とインタプリタ型言語.jpg)



### ◆ コンパイラによるコンパイラ型言語の翻訳（じ、こ、い、さい、せい、実行）

コードを、バイナリ形式のオブジェクトコードとして、まとめて機械語に翻訳した後、CPUに対して命令が実行される。

**【具体例】**

C#

![コンパイラ言語](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/コンパイラ言語.png)

- **コンパイラによるコンパイラ型言語の翻訳の流れ**

![字句解析、構文解析、意味解析、最適化](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/字句解析、構文解析、意味解析、最適化.png)

1. **Lexical analysis（字句解析）**

   ソースコードの文字列を言語の最小単位（トークン）の列に分解。

   ![構文規則と説明](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/構文規則と説明.png)

2. **Syntax analysis（構文解析）**

   トークンの列をツリー構造に変換。

3. **Semantics analysis（意味解析）**

   ツリー構造を基に、ソースコードに論理的な誤りがないか解析。

4. **Code optimization（コード最適化）**

   ソースコードの冗長な部分を削除または編集。機械語をより短くするこができる。

5. **Code generation（コード生成）**

   最適化されたコードをバイナリ形式のオブジェクトコードに変換。

6. **命令の実行**

   オブジェクトコードを基に、命令が実行される。



### ◆ インタプリタによるインタプリタ型言語の翻訳（じ、こ、い、実行）

コードを、一行ずつ機械語に変換し、順次、命令を実行する言語。

**【具体例】**

PHP、Ruby、JavaScript、Python

![インタプリタ言語](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/インタプリタ言語.png)

- **インタプリタによるインタプリタ型言語の翻訳の流れ**

![字句解析、構文解析、意味解析、最適化](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/字句解析、構文解析、意味解析、最適化.png)

1. **Lexical analysis（字句解析）**

   ソースコードの文字列を言語の最小単位（トークン）の列に分解。

   ![構文規則と説明](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/構文規則と説明.png)

2. **Syntax analysis（構文解析）**

   トークンの列をツリー構造に変換。ソースコードから構造体を構築することを構文解析といい、Htmlを構文解析してDOMツリーを構築する処理とは別物なので注意。

3. **Semantics analysis（意味解析）**

   ツリー構造を基に、ソースコードに論理的な誤りがないか解析。

4. **命令の実行**

   意味解析の結果を基に、命令が実行される。
   
5. **１から４を繰り返す**



### ◆ 両言語の中間型であるJavaによる命令までの流れ

1. コードを、中間的なオブジェクトコードとして、変換する。
2. JVM：Java Virtual Machine内で、インタプリタによって、オブジェクトコードを機械語に翻訳する。
3. 結果的に、OS（制御プログラム？）に依存せずに、命令を実行できる。（C言語）

![Javaによる言語処理_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Javaによる言語処理_1.png)

![矢印_80x82](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/矢印_80x82.jpg)

![Javaによる言語処理_2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Javaによる言語処理_2.png)

![矢印_80x82](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/矢印_80x82.jpg)

![Javaによる言語処理_3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Javaによる言語処理_3.png)



- **C言語とJavaのOSへの依存度比較**

![CとJavaのOSへの依存度比較](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/CとJavaのOSへの依存度比較.png)



- **ヒープ領域とスタック領域について**

[https://www.omotenashi-mind.com/index.php?title=Java%EF%BC%9A%E6%84%8F%E5%A4%96%E3%81%A8%E6%95%99%E3%82%8F%E3%82%8B%E6%A9%9F%E4%BC%9A%E3%81%AE%E5%B0%91%E3%81%AA%E3%81%84%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86%E3%81%AE%E3%81%8A%E8%A9%B1(4)](https://www.omotenashi-mind.com/index.php?title=Java：意外と教わる機会の少ないメモリ管理のお話(4))



### ◆ リンクとビルド

コンパイラやインタプリタによる翻訳では、ソースコードは機械語からなるオブジェクトコードに変換される（インタプリタ言語であっても、このプロセスはコンパイルと言うらしい…）。コンパイル後に、各オブジェクトコードはリンクされる。この一連のプロセスを『ビルド』という。

※Vue.jsを使用するためには『asset:build』や『asset:watch』が必要であるが、まさにこのため。

![ビルドとコンパイル](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ビルドとコンパイル.jpg)



# 01-04. 基本ソフトウェアの制御プログラム（カーネル）

### ◆ ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### ◆ 基本ソフトウェア（再掲）

![基本ソフトウェアの構成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/基本ソフトウェアの構成.png)



### ◆ ジョブ管理

クライアントは、マスタスケジュールに対して、ジョブを実行するための命令を与える。

![ジョブ管理とタスク管理の概要](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ジョブ管理とタスク管理の概要.jpg)

**【具体例】**

Windowsのタスクスケジューラでは、決められた時間または一定間隔でプログラムやスクリプトを実行することができる。

![タスクスケジューラ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/タスクスケジューラ.png)



### ◆ マスタスケジュラ、ジョブスケジュラ（タスクスケジューラ）

ジョブとは、プロセスのセットのこと。マスタスケジュラは、ジョブスケジュラにジョブの実行を命令する。データをコンピュータに入力し、複数の処理が実行され、結果が出力されるまでの一連の処理のこと。『Task』と『Job』の定義は曖昧なので、『process』と『set of processes』を使うべきとのこと。

引用：https://stackoverflow.com/questions/3073948/job-task-and-process-whats-the-difference/31212568

複数のジョブ（プログラムやバッチ）の起動と終了を制御したり、ジョブの実行と終了を監視報告するソフトウェア。ややこしいことに、タスクスケジューラとも呼ぶ。

- **Reader**

ジョブ待ち行列に登録

- **Initiator**

ジョブステップに分解

- **Terminator**

出力待ち行列に登録

- **Writer**

優先度順に出力の処理フローを実行



### ◆ Initiatorによるジョブのジョブステップへの分解

Initiatorによって、ジョブはジョブステップに分解される。

![ジョブからジョブステップへの分解](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ジョブからジョブステップへの分解.png)



### ◆ タスク管理

![ジョブステップからタスクの生成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ジョブステップからタスクの生成.png)

タスクとは、スレッドに似たような、単一のプロセスのこと。Initiatorによるジョブステップから、タスク管理によって、タスクが生成される。タスクが生成されると実行可能状態になる。ディスパッチャによって実行可能状態から実行状態になる。

- **優先順方式**

各タスクに優先度を設定し、優先度の高いタスクから順に、ディスパッチしていく方式。

- **到着順方式**

待ち行列に登録されたタスクから順に、ディスパッチしていく方式。

![到着順方式_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/到着順方式_1.png)

**【具体例】**

以下の様に、タスクがCPUに割り当てられていく。

![到着順方式_2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/到着順方式_2.png)

- **Round robin 方式**

Round robinは、『総当たり』の意味。一定時間（タイムクウォンタム）ごとに、実行状態にあるタスクが強制的に待ち行列に登録される。交代するように、他のタスクがディスパッチされる。

  ![ラウンドロビン方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ラウンドロビン方式.png)

**【具体例】**

生成されたタスクの到着時刻と処理時間は以下のとおりである。強制的なディスパッチは、『20秒』ごとに起こるとする。

![優先順方式_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/優先順方式_1.png)

1. タスクAが0秒に待ち行列へ登録される。
2. 20秒間、タスクAは実行状態へ割り当てられる。
3. 20秒時点で、タスクAは実行状態から待ち行列に追加される。同時に、待ち行列の先頭にいるタスクBは、実行可能状態から実行状態にディスパッチされる。
4. 40秒時点で、タスクCは実行状態から待ち行列に追加される。同時に、待ち行列の先頭にいるタスクAは、実行可能状態から実行状態にディスパッチされる。

![優先順方式_2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/優先順方式_2.png)



### ◆ 入出力管理

アプリケーションから低速な周辺機器へデータを出力する時、まず、CPUはスプーラにデータを出力する。Spoolerは、全てのデータをまとめて出力するのではなく、一時的に補助記憶装置（Spool）にためておきながら、少しずつ出力する（Spooling）。

  ![スプーリング](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/スプーリング.jpg)



# 01-05. デバイスドライバ



# 01-06. Firmware

システムソフトウェア（ミドルウェア ＋ 基本ソフトウェア）とハードウェアの間の段階にあるソフトウェア。ROMに組み込まれている。

### ◆ BIOS：Basic Input/Output System

![BIOS](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/BIOS.jpg)



### ◆ UEFI：United Extensible Firmware Interface

Windows 8以降で採用されている新しいFirmware

![UEFIとセキュアブート](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/UEFIとセキュアブート.JPG)



# 02-01. ハードウェアについて

### ◆ ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### ◆ CPU（プロセッサ）

CPUは制御と演算を行う。CPUの制御部分は、プログラムの命令を解釈して、コンピュータ全体を制御。CPUの演算部分は、計算や演算処理を行う。特、『**算術論理演算装置（ALU：Arithmetic and Logic Unit）**』とも呼ぶ。



### ◆ RAM（メインメモリ＋キャッシュメモリ）

プログラムやデータを一時的に記憶し、コンピュータの電源を切るとこれらは消える。



### ◆ ROM

プログラムやデータを長期的に記憶し、コンピュータの電源を切ってもこれらは消えない。



### ◆ 入力装置

コンピュータにデータを入力。キーボード、マウス、スキャナなど。



### ◆ 出力装置

コンピュータからデータを出力。ディスプレイ、プリンタなど。



# 02-02. CPU（プロセッサ）

### ◆ IntelとAMDにおけるCPUの歴史（※2009年まで）

![IntelとAMDにおけるCPUの歴史](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/IntelとAMDにおけるCPUの歴史.png)



### ◆ クロック周波数

CPUの回路が処理と歩調を合わせるために用いる信号を、『クロック』と言う。一定時間ごとにクロックが起こる時、１秒間にクロックが何回起こるかを『クロック周波数』という。これは、Hzで表される。ちなみに、ワイのパソコンのクロック周波数は2.60GHzでした。

（例1）3Hz = 3 (クロック数／秒)

（例2）2.6GHz = 2.6×10^9  (クロック数／秒)

![クロック数比較](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/クロック数比較.png)



### ◆ MIPS：Million Instructions Per Second（×10^6 命令数／秒）

CPUが1秒間に何回命令を実行するかを表す。

（例題）

命令当たりの平均クロック数は、『(4×0.3)＋(8×0.6)＋(10×0.1) 』から、『7』と求められる。

700Hz (×10^6 クロック数／秒) ÷ 7 (クロック数／命令) = 100 (×10^6 命令数／秒)

![MIPSの例題](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/MIPSの例題.png)

- **1命令当たりの実行時間 (秒／命令) の求め方**

  1 ÷ 100 (×10^6 命令／秒) = 10n (秒／命令)



# 02-03. 物理メモリ（RAM + ROM）

### ◆ 物理メモリの種類

『物理メモリ』は、RAMとROMに大きく分けられる。

![p162](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p162.png)



### ◆ RAM：Read Access Memory

RAMは、メインメモリとして使われる『Dynamic RAM』と、キャッシュメモリとして使われる『Static RAM』に分解される。

- **Dynamic RAM**

  メインメモリとして用いられる。よく見るやつ。

  ![Dynamic RAM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Dynamic RAM.jpg)

- **Static RAM**

  キャッシュメモリとして用いられる。
  
  ![Static RAM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Static RAM.jpg)
  



### ◆ ROM：Read Only Memory

- **Mask ROM**

  ![p164-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p164-1.png)

- **Programmable ROM**

  ![p164-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p164-2.png)



### ◆ Garbage collection

プログラムが確保したメモリ領域のうち、不要になった領域を自動的に解放する機能。

- **JavaにおけるGarbage collection**

Javaでは、JVM：Java Virtual Machine（Java仮想マシン）が、メモリ領域をオブジェクトに自動的に割り当て、また一方で、不要になったメモリ領域の解放を行う。一方で自動的に行う。



# 02-04. SRAM

CPUから命令が起こるとき、CPU、DRAM、ハードディスク間には、読み込みと書き出しの処理速度に差がある。

![p169](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p169.png)



### ◆ キャッシュメモリとは

- **一次キャッシュメモリと二次キャッシュメモリ**

  CPUとメインメモリの間に、キャッシュメモリを何段階か設置し、CPUとメインメモリの間の読み込みと書き出しの処理速度の差を緩和させる。

![メモリキャッシュ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/メモリキャッシュ.GIF)



### ◆ キャッシュメモリの読み込み方法

- **ユーザー ➔ メインメモリ ➔ 二次キャッシュメモリ ➔ 一次キャッシュメモリ**

1. ユーザーが、パソコンに対して命令を与える。
2. CPUは、命令をメインメモリに書き込む。
3. CPUは、メインメモリから命令を読み出す。
4. CPUは、二次キャッシュメモリに書き込む。
5. CPUは、一次キャッシュメモリに書き込む。
6. CPUは、命令を実行する。

![メモリとキャッシュメモリ_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/メモリとキャッシュメモリ_1.jpg)

- **実例**

  タスクマネージャのパフォーマンスタブで、n次キャッシュメモリがどのくらい使われているのかを確認できる。

  ![キャッシュメモリの実例](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/キャッシュメモリの実例.png)



### ◆ キャッシュメモリへの書き込み方式の種類

- **Write-throught 方式**

  CPUは、命令をメインメモリとキャッシュメモリの両方に書き込む。常にメインメモリとキャッシュメモリの内容が一致している状態を確保できるが、メモリへの書き込みが頻繁に行われるので遅い。

  ![Write-through方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Write-through方式.jpg)

- **Write-back 方式**

  CPUは、キャッシュメモリのみに書き込む。次に、キャッシュメモリがメインメモリに書き込む。メインメモリとキャッシュメモリの内容が一致している状態を必ずしも確保できないが、メインメモリへの書き込み回数が少ないため速い

![Write-back方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Write-back方式.jpg)



### ◆ 実効アクセス時間

![p171-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p171-1.png)

  

# 02-05. 仮想メモリのアドレス空間管理

### ◆ Demand方式

### ◆ Segment方式

仮想メモリの実装方法の一つ。仮想メモリのアドレス空間を『可変長』の領域（セグメント）、また物理メモリのアドレス空間を『可変長』の領域（セグメント）に分割し、管理する方式。



# 02-06. ページング方式

以下の用語に統一する。

- **主記憶 ⇒ 物理メモリ（メインメモリ＋キャッシュメモリ）**

- **補助記憶 ⇒ ハードディスク**

- **仮想記憶 ⇒ 仮想メモリ**



### ◆ ページ構造

仮想メモリの実装方法の一つ。仮想メモリのアドレス空間を『固定長』の領域（ページ）、また物理メモリのアドレス空間を『固定長』の領域（ページフレーム）に分割し、管理する方式。

![ページの構造](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページの構造.png)



### ◆ ページインとページアウト

ハードディスクから物理メモリのページフレームにページを読み込むことを『Page-in』という。また、物理メモリのページフレームからハードディスクにページを追い出すことを『Page-out』という。

![ページインとページアウト](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページインとページアウト.png)



### ◆ 仮想メモリとのマッピングによる大容量アドレス空間の実現

仮想メモリのアドレス空間を、物理メモリのアドレス空間とハードディスクにマッピングすることによって、物理メモリのアドレス空間を疑似的に大きく見せかけることができる。

![仮想メモリとのマッピングによる大容量アドレス空間の再現_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリとのマッピングによる大容量アドレス空間の再現_1.png)

ちなみに、富士通の仮想メモリの容量は、以下の通り。

![仮想メモリのアドレス空間の容量設定](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリのアドレス空間の容量設定.png)



### ◆ MMU：Memory Management Unit（メモリ管理ユニット）

- **MMUにおける動的アドレス変換機構**

MMUによって、仮想メモリのアドレスは、物理メモリのアドレスに変換される。この仕組みを、『動的アドレス変換機構』と呼ぶ。

![メモリ管理ユニット](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/メモリ管理ユニット.png)

- **アドレス変換の仕組み**

1. ページの仮想アドレスを、ページ番号とページオフセットに分割する。

   ![ページの構造](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページの構造.png)

2. ページ番号とページフレームのアドレスを対応づけるページテーブルを利用して、 仮想アドレスの指すページフレームを探す。

3. ページフレームのアドレスとページオフセットから物理アドレスを計算する。

![仮想メモリとのマッピングによる大容量アドレス空間の再現_3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリとのマッピングによる大容量アドレス空間の再現_3.png)

- **ページテーブルにおける仮想ページ番号と物理ページ番号の対応づけ**

![仮想メモリとのマッピングによる大容量アドレス空間の再現_4](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリとのマッピングによる大容量アドレス空間の再現_4.png)



# 02-07. 物理メモリのアドレス空間管理

### ◆ 固定区画方式（同じ大きさの区画に分割する方式）

- **単一区画方式**

物理メモリを一つの区画として扱い、プログラムを読み込む。単一のプログラムしか読み込めず、余りのメモリ領域は利用できない。

![単一区画方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/単一区画方式.png)

- **多重区画方式**

物理メモリを複数の同じ大きさの区画に分割し、各区画にプログラムを読み込む。複数のプログラムを読み込むことができるが、単一区画方式と同様に、余ったメモリ領域は利用できない。



![多重区画方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/多重区画方式.png)



### ◆ 可変区画方式（様々な大きさの区画に分割する方式）

プログラムの大きさに応じて、区画を様々な大きさの区画に分割し、プログラムを読み込む。固定区画方式とは異なり、メモリ領域を有効に利用できる。

![可変区画方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/可変区画方式.png)



### ◆ オーバーレイ方式

### ◆ フラグメンテーション／メモリコンパクション

### ◆ スワッピング方式



# 02-08. Page fault発生時の処理

### ◆ Page faultとは

ハードディスクから物理メモリのアドレス空間への割り込み処理のこと。プログラムが、仮想メモリのアドレス空間のページにアクセスし、そのページが物理メモリのアドレス空間にマッピングされていなかった場合に、ハードディスクから物理メモリのアドレス空間に『ページイン』が起こる。

![ページフォールト](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページフォールト.png)



### ◆ Page Replacementアルゴリズム

ページアウトのアルゴリズムのこと。ハードディスクから物理メモリのページフレームにページインを行う時に、アルゴリズムの各方式で、物理メモリからハードディスクにページアウトするページが異なる。

- **『FIFO方式：First In First Out』『LIFO方式：Last In First Out』**

  ![p261-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-2.png)

  ![p261-3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-3.png)

- **『LRU方式：Least Recently Used』『LFU方式：Least Frequently Used』**

  ![p261-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-1.png)

  ![p261-4](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-4.png)



# 02-09. アドレス空間管理におけるプログラムの種類

### ◆ Reusable（再使用可能プログラム）

一度実行すれば、再度、ハードディスクから物理メモリに読み込むことをせずに、実行を繰り返せるプログラムのこと。

![再使用可能](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/再使用可能.gif)



### ◆ Reentrant（再入可能プログラム）

再使用可能の性質をもち、また複数のプログラムから呼び出されても、互いの呼び出しが干渉せず、同時に実行できるプログラムのこと。

![再入可能](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/再入可能.gif)



### ◆ Relocatable（再配置可能プログラム）

ハードディスクから物理メモリへ読み込む時に、アドレス空間上のどこに配置されても実行できるプログラムのこと。

![再配置可能](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/再配置可能.gif)



# 02-10. ディスクメモリ

CPU、メインメモリ、ストレージ間には、読み込みと書き出しの処理速度に差がある。（※再度記載）

![p169](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p169.png)



### ◆ ディスクメモリの機能

メインメモリとハードディスクの間に、ディスクキャッシュを設置し、読み込みと書き出しの処理速度の差を緩和させる。

![ディスクキャッシュ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ディスクキャッシュ.gif)



# 02-11. ハードディスク

### ◆ Defragmentation

断片化されたデータ領域を整理整頓する。

![p184-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p184-1.png)

![p184-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p184-2.png)



### ◆ RAID：Redundant Arrays of Inexpensive Disks

複数のハードディスクを仮想的に一つのハードディスクであるかのようにして、データを管理する技術。

- **RAID0（Striping）**

  データを、複数のハードディスクに分割して書き込む。

- **RAID1（Mirroring）**

  データを、複数のハードディスクに同じように書き込む。

- **RAID5（Striping with parity）**

  データとパリティ（誤り訂正符号）を、3つ以上のハードディスクに書き込む。

![RAIDの種類](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/RAIDの種類.png)



# 02-12. GPUとVRAM

GPUとVRAMの容量によって、扱うことのできる解像度と色数が決まる。

![VRAM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/VRAM.jpg)

富士通PCのGPUとVRAMの容量は、以下の通り。

![本パソコンのVRAMスペック](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/本パソコンのVRAMスペック.jpg)

色数によって、１ドット当たり何ビットを要するが異なる。

![p204](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p204.jpg)



# 03-01. 入出力装置


### ◆ キーボードからポインティングデバイス

- **ジョイスティック**

  


### ◆ 読み取り装置

- **イメージスキャナ**

- **Optical Character Reader**

  紙上の文字を文字データとして読み取る装置。

- **Optical Mark Reader**

  マークシートの塗り潰し位置を読み取る装置。

  ![ORM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ORM.png)

- **キャプチャカード**

- **デジタルカメラ**




### ◆ ディスプレイ 

- **CRTディスプレイ**

- **液晶ディスプレイ**

  電圧の有無によって液晶分子を制御。外部からの光によって画面を表示させる。

  ![液晶分子](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/液晶分子.png)

  ![液晶ディスプレイ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/液晶ディスプレイ.jpg)

- **有機ELディスプレイ**

  有機化合物に電圧を加えることによって発光させ、画面を表示させる。

  ![有機ELディスプレイ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/有機ELディスプレイ.jpg)

- **プラズマディスプレイ**

  ![プラズマディスプレイ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/プラズマディスプレイ.gif)

  2枚のガラスの間に、封入された希ガスに電圧をかけると放電し、紫外線が出る。そして、この紫外線が蛍光体を発光させることによって画面を表示する。  液晶ディスプレイとのシェア差が大きくなり、2014年に世界的に生産が終了された。

  ![パナソニック製プラズマディスプレイ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/パナソニック製プラズマディスプレイ.jpg)

- **LEDディスプレイ**

![LEDディスプレイ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/LEDディスプレイ.jpg)

2018年1月に開催された「CES 2018」でサムスンが発表した“マイクロLEDテレビ”「The Wall」は、従来の「液晶」や「有機EL」とは異なる新たな表示方式を採用したテレビとして、大きな話題となった。




### ◆ プリンタ

- **ドットインパクトプリンタ**

  ![ドットインパクトプリンタ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドットインパクトプリンタ.jpg)

  ![ドットインパクトプリンタの仕組み](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドットインパクトプリンタの仕組み.jpg)

- **インクジェットプリンタ**

  ![インクジェットプリンタ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/インクジェットプリンタ.jpg)

  ![インクジェットプリンタの仕組み](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/インクジェットプリンタの仕組み.jpg)

- **レーザプリンタ**

  ![レーザプリンタ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/レーザプリンタ.jpg)

  ![レーザプリンタの仕組み](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/レーザプリンタの仕組み.jpg)

- **プリンタの解像度**

  １インチ当たりのドット数（dpi）によって、解像度が異なる。復習ではあるが、PC上では、ドット数がどのくらいのビット数を持つかで、解像度が変わる。

![DPI](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/DPI.jpg)

dpiが大きくなるにつれて、解像度は大きくなる。

![DPIの比較](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/DPIの比較.jpg)

- **プリンタの印字速度**

  ![CPS と PPM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/CPS と PPM.jpg)




# 03-02 入出力インターフェイス

### ◆ Serial interface vs. Parallel interface

シリアルインターフェイスは、情報を1bitずつ転送する方式。パラレルインターフェイスは、複数のbitの情報を同時に転送する方式。パラレルインターフェイスは、同時にデータを送信し、同時に受信しなければならない。配線の形状や長さによって、信号の転送時間は異なる。動作クロックが速ければ速いほど、配線間の同時転送に誤差が生じてしまうため、現代の高スペックパソコンには向いていない。

![パラレルインターフェイスは配線の長さが関係してくる](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/パラレルインターフェイスは配線の長さが関係してくる.png)

![シリアルvs パラレル の違い](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/シリアルvs パラレル の違い.jpeg)



### ◆ Serial interface が用いられている例

- **USB（Universal Serial Bus）**

![usbケーブル](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/usbインターフェイス.png)

- **IEEE1394**

ビデオカメラとの接続に用いられるインターフェイス

![ieeeケーブル](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ieeeインターフェイス.jpg)



### ◆ Parallel interface が用いられている例

- **IDE（Integrated Drive Electronics）**

ハードディスクとの接続に用いられるインターフェイス。

![ideケーブル](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ideインターフェイス.jpg)

- **SCSI（Small Computer System Interface）**

ハードディスク、CD-ROM、イメージスキャナなど、様々な周辺機器をデイジーチェーンするために用いるインターフェイス。

![scsiケーブル](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/scsiインターフェイス.jpg)



### ◆ 無線インターフェイス

- **IrDA（infrared Data Assoiciation）**
  赤外線を使って、無線通信を行うためのインターフェイス。

![irDAインターフェイス](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/irDAインターフェイス.jpg)

- **Bluetooth**
  2.4GHzの電波を使って無線通信を行うためのインターフェイス。
  



# 04-01. 組み込み機器と組み込みシステム

### ◆ 組み込みシステムとは

組み込み機器（限定的な用途向けに特定の機能を果たす事を目的とした機器）を制御するシステムのこと。

※パソコンは、汎用機器（汎用的な用途向けに多様な機能を果たす事を目的とした機器）に分類される。

![組み込みシステム](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/組み込みシステム.png)



### ◆ マイクロコンピュータとは

CPUとして、『マイクロプロセッサ』を用いたコンピュータのこと。

![マイコン](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/マイコン.png)



### ◆ センサによるアナログ情報の入力

外部のアナログ情報を計測し、マイクロコンピュータへ転送する。

**【具体例】：温度センサ、加速度センサ、照度センサ、…**

![p119-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p119-2.png)



### ◆ A/D変換器によるアナログ情報からデジタル情報への変換

![AD変換](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/AD変換.png)



### ◆ **D/A変換器**によるデジタル情報からアナログ情報への変換

![DA変換](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/DA変換.png)



### ◆ Actuater

入力されたエネルギーもしくはコンピュータが出力した*電気信号*を物理的運動に変換する装置のこと。

![p119-3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p119-3.png)



### ◆ 組み込みシステムの制御方式の種類

- **シーケンス制御**

  決められた順序や条件に従って、制御の各段階を進めていく制御方式。

  **【具体例】**

  洗濯機

  ![p120-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p120-1.png)

- **フィードバック制御**

  その時の状況を定期的に計測し、目標値との差分を基に、出力を調節する制御方式。

  **【具体例】**

  エアコン

  ![p120-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p120-2.png)