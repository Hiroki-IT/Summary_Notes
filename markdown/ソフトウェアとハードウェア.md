# 目次

<!-- TOC -->

- [01-01. ソフトウェアの具体例](#01-01-ソフトウェアの具体例)
    - [:pushpin: OSS：Open Source Softwareとは](#pushpin-ossopen-source-softwareとは)
    - [:pushpin: OSSの具体例](#pushpin-ossの具体例)
    - [:pushpin: Linux Distribution（Linuxの種類）](#pushpin-linux-distributionlinuxの種類)
- [01-02. ソフトウェアについて](#01-02-ソフトウェアについて)
    - [:pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで](#pushpin-ユーザの操作が命令としてハードウェアに伝わるまで)
    - [:pushpin: 応用ソフトウェア](#pushpin-応用ソフトウェア)
    - [:pushpin: Middleware](#pushpin-middleware)
    - [:pushpin: 基本ソフトウェア（広義のOS）](#pushpin-基本ソフトウェア広義のos)
    - [:pushpin: Firmware](#pushpin-firmware)
    - [:pushpin: デバイスドライバ](#pushpin-デバイスドライバ)
- [01-03. 応用ソフトウェアの種類](#01-03-応用ソフトウェアの種類)
    - [:pushpin: 応用ソフトウェア（アプリケーション）の一覧](#pushpin-応用ソフトウェアアプリケーションの一覧)
    - [:pushpin: ネイティブアプリケーション](#pushpin-ネイティブアプリケーション)
    - [:pushpin: Webアプリケーションとクラウドアプリケーション](#pushpin-webアプリケーションとクラウドアプリケーション)
    - [:pushpin: ハイブリッドアプリケーション](#pushpin-ハイブリッドアプリケーション)
- [01-04. 基本ソフトウェアの汎用言語プログラム](#01-04-基本ソフトウェアの汎用言語プログラム)
    - [:pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）](#pushpin-ユーザの操作が命令としてハードウェアに伝わるまで再掲)
    - [:pushpin: 基本ソフトウェア（再掲）](#pushpin-基本ソフトウェア再掲)
    - [:pushpin: コンパイラ型言語、インタプリタ型言語、JavaまたはJava仮想マシン型言語](#pushpin-コンパイラ型言語インタプリタ型言語javaまたはjava仮想マシン型言語)
    - [:pushpin: コンパイラによるコンパイラ型言語の翻訳（じ、こ、い、さい、せい、リンク、実行）](#pushpin-コンパイラによるコンパイラ型言語の翻訳じこいさいせいリンク実行)
    - [:pushpin: インタプリタによるインタプリタ型言語の翻訳（じ、こ、い、実行）](#pushpin-インタプリタによるインタプリタ型言語の翻訳じこい実行)
    - [:pushpin: Java仮想マシンによるJavaまたはJava仮想マシン型言語の翻訳](#pushpin-java仮想マシンによるjavaまたはjava仮想マシン型言語の翻訳)
- [01-05. 基本ソフトウェアの制御プログラム（カーネル）](#01-05-基本ソフトウェアの制御プログラムカーネル)
    - [:pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）](#pushpin-ユーザの操作が命令としてハードウェアに伝わるまで再掲-1)
    - [:pushpin: 基本ソフトウェア（再掲）](#pushpin-基本ソフトウェア再掲-1)
    - [:pushpin: ジョブ管理](#pushpin-ジョブ管理)
    - [:pushpin: マスタスケジュラ、ジョブスケジュラ](#pushpin-マスタスケジュラジョブスケジュラ)
    - [:pushpin: Initiatorによるジョブのジョブステップへの分解](#pushpin-initiatorによるジョブのジョブステップへの分解)
    - [:pushpin: タスク管理](#pushpin-タスク管理)
    - [:pushpin: 入出力管理](#pushpin-入出力管理)
- [01-06. デバイスドライバ](#01-06-デバイスドライバ)
- [01-07. Firmware](#01-07-firmware)
    - [:pushpin: BIOS：Basic Input/Output System](#pushpin-biosbasic-inputoutput-system)
    - [:pushpin: UEFI：United Extensible Firmware Interface](#pushpin-uefiunited-extensible-firmware-interface)
- [02-01. ハードウェアについて](#02-01-ハードウェアについて)
    - [:pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）](#pushpin-ユーザの操作が命令としてハードウェアに伝わるまで再掲-2)
    - [:pushpin: CPU（プロセッサ）](#pushpin-cpuプロセッサ)
    - [:pushpin: RAM（メインメモリ＋キャッシュメモリ）](#pushpin-ramメインメモリ＋キャッシュメモリ)
    - [:pushpin: ROM](#pushpin-rom)
    - [:pushpin: 入力装置](#pushpin-入力装置)
    - [:pushpin: 出力装置](#pushpin-出力装置)
- [02-02. CPU（プロセッサ）](#02-02-cpuプロセッサ)
    - [:pushpin: IntelとAMDにおけるCPUの歴史（※2009年まで）](#pushpin-intelとamdにおけるcpuの歴史※2009年まで)
    - [:pushpin: クロック周波数](#pushpin-クロック周波数)
    - [:pushpin: MIPS：Million Instructions Per Second（×10^6 命令数／秒）](#pushpin-mipsmillion-instructions-per-second×10^6-命令数／秒)
- [02-03. 物理メモリ（RAM + ROM）](#02-03-物理メモリram--rom)
    - [:pushpin: 物理メモリの種類](#pushpin-物理メモリの種類)
    - [:pushpin: RAM：Read Access Memory](#pushpin-ramread-access-memory)
    - [:pushpin: ROM：Read Only Memory](#pushpin-romread-only-memory)
    - [:pushpin: Garbage collection](#pushpin-garbage-collection)
- [02-04. SRAM](#02-04-sram)
    - [:pushpin: キャッシュメモリとは](#pushpin-キャッシュメモリとは)
    - [:pushpin: キャッシュメモリの読み込み方法](#pushpin-キャッシュメモリの読み込み方法)
    - [:pushpin: キャッシュメモリへの書き込み方式の種類](#pushpin-キャッシュメモリへの書き込み方式の種類)
    - [:pushpin: 実効アクセス時間](#pushpin-実効アクセス時間)
- [02-05. 仮想メモリのアドレス空間管理](#02-05-仮想メモリのアドレス空間管理)
    - [:pushpin: Demand方式](#pushpin-demand方式)
    - [:pushpin: Segment方式](#pushpin-segment方式)
- [02-06. ページング方式](#02-06-ページング方式)
    - [:pushpin: ページ構造](#pushpin-ページ構造)
    - [:pushpin: ページインとページアウト](#pushpin-ページインとページアウト)
    - [:pushpin: 仮想メモリとのマッピングによる大容量アドレス空間の実現](#pushpin-仮想メモリとのマッピングによる大容量アドレス空間の実現)
    - [:pushpin: MMU：Memory Management Unit（メモリ管理ユニット）](#pushpin-mmumemory-management-unitメモリ管理ユニット)
- [02-07. 物理メモリのアドレス空間管理](#02-07-物理メモリのアドレス空間管理)
    - [:pushpin: 固定区画方式（同じ大きさの区画に分割する方式）](#pushpin-固定区画方式同じ大きさの区画に分割する方式)
    - [:pushpin: 可変区画方式（様々な大きさの区画に分割する方式）](#pushpin-可変区画方式様々な大きさの区画に分割する方式)
    - [:pushpin: オーバーレイ方式](#pushpin-オーバーレイ方式)
    - [:pushpin: フラグメンテーション／メモリコンパクション](#pushpin-フラグメンテーション／メモリコンパクション)
    - [:pushpin: スワッピング方式](#pushpin-スワッピング方式)
- [02-08. Page fault発生時の処理](#02-08-page-fault発生時の処理)
    - [:pushpin: Page faultとは](#pushpin-page-faultとは)
    - [:pushpin: Page Replacementアルゴリズム](#pushpin-page-replacementアルゴリズム)
- [02-09. アドレス空間管理におけるプログラムの種類](#02-09-アドレス空間管理におけるプログラムの種類)
    - [:pushpin: Reusable（再使用可能プログラム）](#pushpin-reusable再使用可能プログラム)
    - [:pushpin: Reentrant（再入可能プログラム）](#pushpin-reentrant再入可能プログラム)
    - [:pushpin: Relocatable（再配置可能プログラム）](#pushpin-relocatable再配置可能プログラム)
- [02-10. ディスクメモリ](#02-10-ディスクメモリ)
    - [:pushpin: ディスクメモリの機能](#pushpin-ディスクメモリの機能)
- [02-11. ハードディスク](#02-11-ハードディスク)
    - [:pushpin: Defragmentation](#pushpin-defragmentation)
    - [:pushpin: RAID：Redundant Arrays of Inexpensive Disks](#pushpin-raidredundant-arrays-of-inexpensive-disks)
- [02-12. GPUとVRAM](#02-12-gpuとvram)
- [03-01. サーバ仮想化とコンテナ仮想化](#03-01-サーバ仮想化とコンテナ仮想化)
    - [:pushpin: ホスト型仮想化](#pushpin-ホスト型仮想化)
    - [:pushpin: ハイパーバイザー型仮想化](#pushpin-ハイパーバイザー型仮想化)
    - [:pushpin: コンテナ型仮想化](#pushpin-コンテナ型仮想化)
- [03-02. 各仮想化のパフォーマンスの比較](#03-02-各仮想化のパフォーマンスの比較)
    - [:pushpin: 起動速度の違い](#pushpin-起動速度の違い)
    - [:pushpin: 処理速度の違い](#pushpin-処理速度の違い)
- [03-03. 仮想サーバの構築](#03-03-仮想サーバの構築)
    - [:pushpin: VagrantによるProviderとProvisionerの操作](#pushpin-vagrantによるproviderとprovisionerの操作)
    - [:pushpin: Providerによる仮想サーバの構築](#pushpin-providerによる仮想サーバの構築)
    - [:pushpin: Provisionerによるソフトウェアのインストール](#pushpin-provisionerによるソフトウェアのインストール)
- [03-04. コンテナの構築](#03-04-コンテナの構築)
    - [:pushpin: Dockerクライアントによるコンテナの操作](#pushpin-dockerクライアントによるコンテナの操作)
    - [:pushpin: Dockerホスト](#pushpin-dockerホスト)
    - [:pushpin: レジストリ](#pushpin-レジストリ)
    - [:pushpin: コンテナを操作するまでの手順](#pushpin-コンテナを操作するまでの手順)
    - [:pushpin: Dockerfileによるイメージのインストールと設定](#pushpin-dockerfileによるイメージのインストールと設定)
    - [:pushpin: Docker Composeによるイメージのビルド、コンテナの構築、コンテナの起動](#pushpin-docker-composeによるイメージのビルドコンテナの構築コンテナの起動)

<!-- /TOC -->
## 01-01. ソフトウェアの具体例

### :pushpin: OSS：Open Source Softwareとは

以下の条件を満たすソフトウェアをOSSと呼ぶ。

1. 利用者は、無償あるいは有償で自由に再配布できる。

2. 利用者は、ソースコードを入手できる。

3. 利用者は、コードを自由に変更できる。また、変更後に提供する場合、異なるライセンスを追加できる。

4. 差分情報の配布を認める場合には、同一性の保持を要求してもかまわない。 ⇒ よくわからない

5. 提供者は、特定の個人やグループを差別できない。

6. 提供者は、特定の分野を差別できない。

7. 提供者は、全く同じOSSの再配布において、ライセンスを追加できない。

8. 提供者は、特定の製品でのみ有効なライセンスを追加できない。

9. 提供者は、他のソフトウェアを制限するライセンスを追加できない。

10. 提供者は、技術的に偏りのあるライセンスを追加できない。

    

### :pushpin: OSSの具体例

![OSS一覧](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/OSS一覧.png)

引用：https://openstandia.jp/oss_info/

- **OS**

  CentOS、Linux、Unix、Ubuntu

- **データベース**

  MySQL、MariaDB

- **プログラミング言語**

  言うまでもない。

- **フレームワーク**

  言うまでもない。

- **OR Mapper**

  言うまでもない。

- **バージョン管理**

  Git、Subversion

- **Webサーバ**

  Apache

- **業務システム**

  Redmine

- **インフラ構築**

  Chef、Puppet

- **クラウド構築**

  Docker



### :pushpin: Linux Distribution（Linuxの種類）

現在、Linuxは3つを源流として、いくつもの派生系へ分岐している。

- **RedHat系**

RedHat、CentOS、Fedora

- **Debian系**

Debian、Ubuntu、

- **Slackware系**

Slackware

![Linux distribution](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Linux distribution.png)



## 01-02. ソフトウェアについて

### :pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで

ソフトウェアには、応用ソフトウェアとシステムソフトウェアがある。

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### :pushpin: 応用ソフトウェア

**【具体例】**

その辺のアプリ



### :pushpin: Middleware

**【具体例】**

- **Webサーバソフトウェア（Apache、Nginx）をもつWebサーバ**
- **APサーバソフトウェア（Apache内蔵、NGINX Unit）をもつAPサーバ**
- **DBサーバをもつデータベース管理システム**

※詳しくは、ネットワークのノートを参照せよ。



### :pushpin: 基本ソフトウェア（広義のOS）

![基本ソフトウェアの構成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/基本ソフトウェアの構成.png)

- **制御プログラム（：別名カーネル）**

  **【具体例】**

  カーネル、マイクロカーネル、モノリシックカーネル

- **言語プロセッサ**

  **【具体例】**

  アセンブラ、コンパイラ、インタプリタというプログラム

- **サービスプログラム**

  **【具体例】**

  ファイル圧縮プログラム



### :pushpin: Firmware



### :pushpin: デバイスドライバ



## 01-03. 応用ソフトウェアの種類

### :pushpin: 応用ソフトウェア（アプリケーション）の一覧

|                        | ネイティブアプリ | Webアプリとクラウドアプリ | ハイブリッドアプリ |
| :--------------------: | :--------------: | :-----------------------: | :----------------: |
| **利用可能な通信状況** |     On／Off      |            On             |      On／Off       |
|                        |                  |                           |                    |
|                        |                  |                           |                    |



### :pushpin: ネイティブアプリケーション

![ネイティブアプリ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ネイティブアプリ.png)

端末のシステムによって稼働するアプリのこと。一度ダウンロードしてしまえば、インターネットに繋がっていなくとも、使用できる。

**【アプリ例】**

Office、BookLiveのアプリ版



### :pushpin: Webアプリケーションとクラウドアプリケーション

![Webアプリ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Webアプリ.png)

- **Webアプリケーション**

Webサーバ上でWebシステムをレンダリングすることによって稼働するアプリのこと。URLをWebサーバにリクエストすることで利用でき、随時、Webサーバとデータ通信を行う。全ての人が無料で利用できるものと、お金を払った人だけが利用できるものがある。

**【全ての人が無料で利用できるWebアプリ例】**

Googleアプリ、Amazon、BookLiveのブラウザ版

**【お金を払った人だけが特定のURLから利用できるWebアプリ例】**

サイボウズ

- **クラウドアプリケーション**

Webサーバ上のシステムによって稼働するアプリのうち、クラウドサービスを提供するもののこと。

**【クラウドアプリ例】**

Google Drive、Dropbox



### :pushpin: ハイブリッドアプリケーション

![Webviewよるアプリパッケージ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Webviewよるアプリパッケージ.png)

![ハイブリッドアプリ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ハイブリッドアプリ.png)

端末でWebviewを稼働させ、WebシステムのレンダリングなどをWebview上で行うアプリのこと。

**【アプリ例】**

クックパッド



## 01-04. 基本ソフトウェアの汎用言語プログラム

### :pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### :pushpin: 基本ソフトウェア（再掲）

![基本ソフトウェアの構成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/基本ソフトウェアの構成.png)



### :pushpin: コンパイラ型言語、インタプリタ型言語、JavaまたはJava仮想マシン型言語

プログラム言語のソースコードは、言語プロセッサによって機械語に変換された後、CPUによって読み込まれる。そして、ソースコードに書かれた様々な処理が実行される。

- **コンパイラとコンパイラ型言語**

  コンパイラという言語プロセッサによって、コンパイラ方式で翻訳される言語。

- **インタプリタとインタプリタ型言語**

  インタプリタという言語プロセッサによって、インタプリタ方式で翻訳される言語をインタプリタ型言語という。

- **JavaやJava仮想マシン型言語**

  Java仮想マシンによって、中間言語方式で翻訳される。

![コンパイル型とインタプリタ型言語](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/コンパイル型とインタプリタ型言語.jpg)



### :pushpin: コンパイラによるコンパイラ型言語の翻訳（じ、こ、い、さい、せい、リンク、実行）

コードを、バイナリ形式のオブジェクトコードとして、まとめて機械語に翻訳した後、CPUに対して命令が実行される。

**【コンパイラ型言語の具体例】**

C#

![コンパイラ言語](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/コンパイラ言語.png)

- **コンパイラ方式によるコンパイラ型言語のビルド**

  コンパイラ（C#）による翻訳では、ソースコードは機械語からなるオブジェクトコードに変換される。コンパイル後に、各オブジェクトコードはリンクされる。この一連のプロセスを『ビルド』という。

![ビルドとコンパイル](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ビルドとコンパイル.jpg)

- **コンパイラ方式の翻訳の流れ**

![字句解析、構文解析、意味解析、最適化](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/字句解析、構文解析、意味解析、最適化.png)

1. **Lexical analysis（字句解析）**

   ソースコードの文字列を言語の最小単位（トークン）の列に分解。 以下に、トークンの分類方法の例を示す。![構文規則と説明](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/構文規則と説明.png)

2. **Syntax analysis（構文解析）**

   トークンの列をツリー構造に変換。

3. **Semantics analysis（意味解析）**

   ツリー構造を基に、ソースコードに論理的な誤りがないか解析。

4. **Code optimization（コード最適化）**

   ソースコードの冗長な部分を削除または編集。機械語をより短くするこができる。

5. **Code generation（コード生成）**

   最適化されたコードをバイナリ形式のオブジェクトコードに変換。

6. **リンク**

   オブジェクトコードをリンクする。
   
7. **命令の実行**

   リンクされたオブジェクトコードを基に、命令が実行される。



### :pushpin: インタプリタによるインタプリタ型言語の翻訳（じ、こ、い、実行）

コードを、一行ずつ機械語に変換し、順次、命令を実行する言語。

※Webサーバを仮想的に構築する時、PHPの言語プロセッサが同時に組み込まれるため、PHPのソースコードの変更はブラウザに反映される。しかし、JavaScriptの言語プロセッサは組み込まれない。そのため、JavaScriptのインタプリタは別に手動で起動する必要がある。

**【インタプリタ型言語の具体例】**

PHP、Ruby、JavaScript、Python

![インタプリタ言語](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/インタプリタ言語.png)

- **インタプリタ方式の翻訳の流れ**

![字句解析、構文解析、意味解析、最適化](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/字句解析、構文解析、意味解析、最適化.png)

1. **Lexical analysis（字句解析）**

   ソースコードの文字列を言語の最小単位（トークン）の列に分解。 以下に、トークンの分類方法の例を示す。![構文規則と説明](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/構文規則と説明.png)

2. **Syntax analysis（構文解析）**

   トークンの列をツリー構造に変換。ソースコードから構造体を構築することを構文解析といい、htmlを構文解析してDOMツリーを構築する処理とは別物なので注意。

3. **Semantics analysis（意味解析）**

   ツリー構造を基に、ソースコードに論理的な誤りがないか解析。

4. **命令の実行**

   意味解析の結果を基に、命令が実行される。
   
5. **１から４をコード行ごとに繰り返す**



### :pushpin: Java仮想マシンによるJavaまたはJava仮想マシン型言語の翻訳

**【JVM型言語の具体例】**

Scala、Groovy、Kotlin

- **中間言語方式の翻訳の流れ**

1. JavaまたはJVM型言語のソースコードを、Javaバイトコードを含むクラスファイルに変換する。
2. JVM：Java Virtual Machine内で、インタプリタによって、クラスデータを機械語に翻訳する。
4. 結果的に、OS（制御プログラム？）に依存せずに、命令を実行できる。（C言語）

![Javaによる言語処理_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Javaによる言語処理_1.png)

![矢印_80x82](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/矢印_80x82.jpg)

![Javaによる言語処理_2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Javaによる言語処理_2.png)

![矢印_80x82](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/矢印_80x82.jpg)

![Javaによる言語処理_3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Javaによる言語処理_3.png)

- **C言語とJavaのOSへの依存度比較**

![CとJavaのOSへの依存度比較](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/CとJavaのOSへの依存度比較.png)

- JVM言語

ソースコード



## 01-05. 基本ソフトウェアの制御プログラム（カーネル）

### :pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### :pushpin: 基本ソフトウェア（再掲）

![基本ソフトウェアの構成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/基本ソフトウェアの構成.png)



### :pushpin: ジョブ管理

クライアントは、マスタスケジュールに対して、ジョブを実行するための命令を与える。

![ジョブ管理とタスク管理の概要](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ジョブ管理とタスク管理の概要.jpg)



### :pushpin: マスタスケジュラ、ジョブスケジュラ

ジョブとは、プロセスのセットのこと。マスタスケジュラは、ジョブスケジュラにジョブの実行を命令する。データをコンピュータに入力し、複数の処理が実行され、結果が出力されるまでの一連の処理のこと。『Task』と『Job』の定義は曖昧なので、『process』と『set of processes』を使うべきとのこと。

引用：https://stackoverflow.com/questions/3073948/job-task-and-process-whats-the-difference/31212568

複数のジョブ（プログラムやバッチ）の起動と終了を制御したり、ジョブの実行と終了を監視報告するソフトウェア。ややこしいことに、タスクスケジューラとも呼ぶ。

- **Reader**

ジョブ待ち行列に登録

- **Initiator**

ジョブステップに分解

- **Terminator**

出力待ち行列に登録

- **Writer**

優先度順に出力の処理フローを実行



### :pushpin: Initiatorによるジョブのジョブステップへの分解

Initiatorによって、ジョブはジョブステップに分解される。

![ジョブからジョブステップへの分解](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ジョブからジョブステップへの分解.png)



### :pushpin: タスク管理

![ジョブステップからタスクの生成](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ジョブステップからタスクの生成.png)

タスクとは、スレッドに似たような、単一のプロセスのこと。Initiatorによるジョブステップから、タスク管理によって、タスクが生成される。タスクが生成されると実行可能状態になる。ディスパッチャによって実行可能状態から実行状態になる。

- **優先順方式**

各タスクに優先度を設定し、優先度の高いタスクから順に、ディスパッチしていく方式。

- **到着順方式**

待ち行列に登録されたタスクから順に、ディスパッチしていく方式。

![到着順方式_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/到着順方式_1.png)

**【具体例】**

以下の様に、タスクがCPUに割り当てられていく。

![到着順方式_2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/到着順方式_2.png)

- **Round robin 方式**

Round robinは、『総当たり』の意味。一定時間（タイムクウォンタム）ごとに、実行状態にあるタスクが強制的に待ち行列に登録される。交代するように、他のタスクがディスパッチされる。

![ラウンドロビン方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ラウンドロビン方式.png)

**【具体例】**

生成されたタスクの到着時刻と処理時間は以下のとおりである。強制的なディスパッチは、『20秒』ごとに起こるとする。

![優先順方式_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/優先順方式_1.png)

1. タスクAが0秒に待ち行列へ登録される。
2. 20秒間、タスクAは実行状態へ割り当てられる。
3. 20秒時点で、タスクAは実行状態から待ち行列に追加される。同時に、待ち行列の先頭にいるタスクBは、実行可能状態から実行状態にディスパッチされる。
4. 40秒時点で、タスクCは実行状態から待ち行列に追加される。同時に、待ち行列の先頭にいるタスクAは、実行可能状態から実行状態にディスパッチされる。

![優先順方式_2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/優先順方式_2.png)



### :pushpin: 入出力管理

アプリケーションから低速な周辺機器へデータを出力する時、まず、CPUはスプーラにデータを出力する。Spoolerは、全てのデータをまとめて出力するのではなく、一時的に補助記憶装置（Spool）にためておきながら、少しずつ出力する（Spooling）。

![スプーリング](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/スプーリング.jpg)



## 01-06. デバイスドライバ



## 01-07. Firmware

システムソフトウェア（ミドルウェア ＋ 基本ソフトウェア）とハードウェアの間の段階にあるソフトウェア。ROMに組み込まれている。

### :pushpin: BIOS：Basic Input/Output System

![BIOS](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/BIOS.jpg)



### :pushpin: UEFI：United Extensible Firmware Interface

Windows 8以降で採用されている新しいFirmware

![UEFIとセキュアブート](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/UEFIとセキュアブート.jpg)



## 02-01. ハードウェアについて

### :pushpin: ユーザの操作が、命令としてハードウェアに伝わるまで（再掲）

![ソフトウェアとハードウェア](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ソフトウェアとハードウェア.png)



### :pushpin: CPU（プロセッサ）

CPUは制御と演算を行う。CPUの制御部分は、プログラムの命令を解釈して、コンピュータ全体を制御。CPUの演算部分は、計算や演算処理を行う。特、『**算術論理演算装置（ALU：Arithmetic and Logic Unit）**』とも呼ぶ。



### :pushpin: RAM（メインメモリ＋キャッシュメモリ）

プログラムやデータを一時的に記憶し、コンピュータの電源を切るとこれらは消える。



### :pushpin: ROM

プログラムやデータを長期的に記憶し、コンピュータの電源を切ってもこれらは消えない。



### :pushpin: 入力装置

コンピュータにデータを入力。キーボード、マウス、スキャナなど。



### :pushpin: 出力装置

コンピュータからデータを出力。ディスプレイ、プリンタなど。



## 02-02. CPU（プロセッサ）

### :pushpin: IntelとAMDにおけるCPUの歴史（※2009年まで）

![IntelとAMDにおけるCPUの歴史](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/IntelとAMDにおけるCPUの歴史.png)



### :pushpin: クロック周波数

CPUの回路が処理と歩調を合わせるために用いる信号を、『クロック』と言う。一定時間ごとにクロックが起こる時、１秒間にクロックが何回起こるかを『クロック周波数』という。これは、Hzで表される。ちなみに、ワイのパソコンのクロック周波数は2.60GHzでした。

（例1）3Hz = 3 (クロック数／秒)

（例2）2.6GHz = 2.6×10^9  (クロック数／秒)

![クロック数比較](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/クロック数比較.png)



### :pushpin: MIPS：Million Instructions Per Second（×10^6 命令数／秒）

CPUが1秒間に何回命令を実行するかを表す。

（例題）

命令当たりの平均クロック数は、『(4×0.3)＋(8×0.6)＋(10×0.1) 』から、『7』と求められる

(クロック周波数) ÷ (クロック当たりの命令数)

= 700Hz (×10^6 クロック数／秒) ÷ 7 (クロック数／命令) 

= 100 (×10^6 命令数／秒)

![MIPSの例題](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/MIPSの例題.png)

- **1命令当たりの実行時間 (秒／命令) の求め方**

  1 ÷ 100 (×10^6 命令／秒) = 10n (秒／命令)



## 02-03. 物理メモリ（RAM + ROM）

### :pushpin: 物理メモリの種類

『物理メモリ』は、RAMとROMに大きく分けられる。

![p162](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p162.png)



### :pushpin: RAM：Read Access Memory

RAMは、メインメモリとして使われる『Dynamic RAM』と、キャッシュメモリとして使われる『Static RAM』に分解される。

- **Dynamic RAM**

  メインメモリとして用いられる。よく見るやつ。

![Dynamic RAM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Dynamic RAM.jpg)

- **Static RAM**

  キャッシュメモリとして用いられる。
  

![Static RAM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Static RAM.jpg)




### :pushpin: ROM：Read Only Memory

- **Mask ROM**

![p164-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p164-1.png)

- **Programmable ROM**

![p164-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p164-2.png)



### :pushpin: Garbage collection

プログラムが確保したメモリ領域のうち、不要になった領域を自動的に解放する機能。

- **JavaにおけるGarbage collection**

Javaでは、JVM：Java Virtual Machine（Java仮想マシン）が、メモリ領域をオブジェクトに自動的に割り当て、また一方で、不要になったメモリ領域の解放を行う。一方で自動的に行う。



## 02-04. SRAM

CPUから命令が起こるとき、CPU、DRAM、ハードディスク間には、読み込みと書き出しの処理速度に差がある。

![p169](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p169.png)



### :pushpin: キャッシュメモリとは

- **一次キャッシュメモリと二次キャッシュメモリ**

  CPUとメインメモリの間に、キャッシュメモリを何段階か設置し、CPUとメインメモリの間の読み込みと書き出しの処理速度の差を緩和させる。

![メモリキャッシュ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/メモリキャッシュ.gif)



### :pushpin: キャッシュメモリの読み込み方法

- **ユーザー ➔ メインメモリ ➔ 二次キャッシュメモリ ➔ 一次キャッシュメモリ**

1. ユーザーが、パソコンに対して命令を与える。
2. CPUは、命令をメインメモリに書き込む。
3. CPUは、メインメモリから命令を読み出す。
4. CPUは、二次キャッシュメモリに書き込む。
5. CPUは、一次キャッシュメモリに書き込む。
6. CPUは、命令を実行する。

![メモリとキャッシュメモリ_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/メモリとキャッシュメモリ_1.jpg)

- **実例**

  タスクマネージャのパフォーマンスタブで、n次キャッシュメモリがどのくらい使われているのかを確認できる。

![キャッシュメモリの実例](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/キャッシュメモリの実例.png)



### :pushpin: キャッシュメモリへの書き込み方式の種類

- **Write-throught 方式**

  CPUは、命令をメインメモリとキャッシュメモリの両方に書き込む。常にメインメモリとキャッシュメモリの内容が一致している状態を確保できるが、メモリへの書き込みが頻繁に行われるので遅い。

![Write-through方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Write-through方式.jpg)

- **Write-back 方式**

  CPUは、キャッシュメモリのみに書き込む。次に、キャッシュメモリがメインメモリに書き込む。メインメモリとキャッシュメモリの内容が一致している状態を必ずしも確保できないが、メインメモリへの書き込み回数が少ないため速い

![Write-back方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Write-back方式.jpg)



### :pushpin: 実効アクセス時間

![p171-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p171-1.png)

  

## 02-05. 仮想メモリのアドレス空間管理

### :pushpin: Demand方式

### :pushpin: Segment方式

仮想メモリの実装方法の一つ。仮想メモリのアドレス空間を『可変長』の領域（セグメント）、また物理メモリのアドレス空間を『可変長』の領域（セグメント）に分割し、管理する方式。



## 02-06. ページング方式

以下の用語に統一する。

- **主記憶 ⇒ 物理メモリ（メインメモリ＋キャッシュメモリ）**

- **補助記憶 ⇒ ハードディスク**

- **仮想記憶 ⇒ 仮想メモリ**



### :pushpin: ページ構造

仮想メモリの実装方法の一つ。仮想メモリのアドレス空間を『固定長』の領域（ページ）、また物理メモリのアドレス空間を『固定長』の領域（ページフレーム）に分割し、管理する方式。

![ページの構造](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページの構造.png)



### :pushpin: ページインとページアウト

仮想メモリは、CPUの処理によって稼働したプログラムの要求を、物理メモリの代理として受け付ける。ハードディスクから物理メモリのページフレームにページを読み込むことを『Page-in』という。また、物理メモリのページフレームからハードディスクにページを追い出すことを『Page-out』という。

![ページインとページアウト](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページインとページアウト.png)



### :pushpin: 仮想メモリとのマッピングによる大容量アドレス空間の実現

仮想メモリのアドレス空間を、物理メモリのアドレス空間とハードディスクにマッピングすることによって、物理メモリのアドレス空間を疑似的に大きく見せかけることができる。

![仮想メモリとのマッピングによる大容量アドレス空間の再現_1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリとのマッピングによる大容量アドレス空間の再現_1.png)

ちなみに、富士通の仮想メモリの容量は、以下の通り。

![仮想メモリのアドレス空間の容量設定](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリのアドレス空間の容量設定.png)



### :pushpin: MMU：Memory Management Unit（メモリ管理ユニット）

- **MMUにおける動的アドレス変換機構**

MMUによって、仮想メモリのアドレスは、物理メモリのアドレスに変換される。この仕組みを、『動的アドレス変換機構』と呼ぶ。

![メモリ管理ユニット](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/メモリ管理ユニット.png)

- **アドレス変換の仕組み**

1. 仮想メモリにおけるページの仮想アドレスを、ページ番号とページオフセットに分割する。

 ![ページの構造](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページの構造.png)

2. ページテーブルを用いて、仮想アドレスのページ番号に対応する物理アドレスのページ番号を探す。
3. 物理ページ番号にページオフセットを再結合し、物理メモリのページフレームの物理アドレスとする。

![仮想メモリとのマッピングによる大容量アドレス空間の再現_3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリとのマッピングによる大容量アドレス空間の再現_3.png)

- **ページテーブルにおける仮想ページ番号と物理ページ番号の対応づけ**

![仮想メモリとのマッピングによる大容量アドレス空間の再現_4](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/仮想メモリとのマッピングによる大容量アドレス空間の再現_4.png)



## 02-07. 物理メモリのアドレス空間管理

### :pushpin: 固定区画方式（同じ大きさの区画に分割する方式）

- **単一区画方式**

物理メモリを一つの区画として扱い、プログラムを読み込む。単一のプログラムしか読み込めず、余りのメモリ領域は利用できない。

![単一区画方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/単一区画方式.png)

- **多重区画方式**

物理メモリを複数の同じ大きさの区画に分割し、各区画にプログラムを読み込む。複数のプログラムを読み込むことができるが、単一区画方式と同様に、余ったメモリ領域は利用できない。

![多重区画方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/多重区画方式.png)



### :pushpin: 可変区画方式（様々な大きさの区画に分割する方式）

プログラムの大きさに応じて、区画を様々な大きさの区画に分割し、プログラムを読み込む。固定区画方式とは異なり、メモリ領域を有効に利用できる。

![可変区画方式](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/可変区画方式.png)



### :pushpin: オーバーレイ方式

### :pushpin: フラグメンテーション／メモリコンパクション

### :pushpin: スワッピング方式



## 02-08. Page fault発生時の処理

### :pushpin: Page faultとは

ハードディスクから物理メモリのアドレス空間への割り込み処理のこと。CPUによって稼働したプログラムが、仮想メモリのアドレス空間のページにアクセスし、そのページが物理メモリのアドレス空間にマッピングされていなかった場合に、ハードディスクから物理メモリのアドレス空間に『ページイン』が起こる。

![ページフォールト](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ページフォールト.png)



### :pushpin: Page Replacementアルゴリズム

ページアウトのアルゴリズムのこと。方式ごとに、物理メモリのページフレームからハードディスクにページアウトするページが異なる。

- **『FIFO方式：First In First Out』と『LIFO方式：Last In First Out』**

![p261-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-2.png)

![p261-3](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-3.png)

- **『LRU方式：Least Recently Used』と『LFU方式：Least Frequently Used』**

![p261-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-1.png)

![p261-4](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p261-4.png)



## 02-09. アドレス空間管理におけるプログラムの種類

### :pushpin: Reusable（再使用可能プログラム）

一度実行すれば、再度、ハードディスクから物理メモリにページインを行わずに、実行を繰り返せるプログラムのこと。

![再使用可能](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/再使用可能.gif)



### :pushpin: Reentrant（再入可能プログラム）

再使用可能の性質をもち、また複数のプログラムから呼び出されても、互いの呼び出しが干渉せず、同時に実行できるプログラムのこと。

![再入可能](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/再入可能.gif)



### :pushpin: Relocatable（再配置可能プログラム）

ハードディスクから物理メモリにページインを行う時に、アドレス空間上のどこに配置されても実行できるプログラムのこと。

![再配置可能](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/再配置可能.gif)



## 02-10. ディスクメモリ

CPU、メインメモリ、ストレージ間には、読み込みと書き出しの処理速度に差がある。（※再度記載）

![p169](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p169.png)



### :pushpin: ディスクメモリの機能

メインメモリとハードディスクの間に、ディスクキャッシュを設置し、読み込みと書き出しの処理速度の差を緩和させる。

![ディスクキャッシュ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ディスクキャッシュ.gif)



## 02-11. ハードディスク

### :pushpin: Defragmentation

断片化されたデータ領域を整理整頓する。

![p184-1](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p184-1.png)

![p184-2](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p184-2.png)



### :pushpin: RAID：Redundant Arrays of Inexpensive Disks

複数のハードディスクを仮想的に一つのハードディスクであるかのようにして、データを管理する技術。

- **RAID0（Striping）**

  データを、複数のハードディスクに分割して書き込む。

- **RAID1（Mirroring）**

  データを、複数のハードディスクに同じように書き込む。

- **RAID5（Striping with parity）**

  データとパリティ（誤り訂正符号）を、3つ以上のハードディスクに書き込む。

![RAIDの種類](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/RAIDの種類.png)



## 02-12. GPUとVRAM

GPUとVRAMの容量によって、扱うことのできる解像度と色数が決まる。

![VRAM](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/VRAM.jpg)

富士通PCのGPUとVRAMの容量は、以下の通り。

![本パソコンのVRAMスペック](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/本パソコンのVRAMスペック.jpg)

色数によって、１ドット当たり何ビットを要するが異なる。

![p204](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/p204.jpg)



## 03-01. サーバ仮想化とコンテナ仮想化

自身の開発環境でWebサイトを動かしたい場合、まず、パソコン内にLinux環境のWebサーバ、APサーバ、DBサーバなどの物理サーバを仮想的に構築する。そして、自身のパソコンをクライアント、各仮想サーバをリクエスト先に見立てて、SSHプロトコルを用いてこれらのサーバにリモートログインする。仮想環境の構築方法にはいくつか種類がある。

### :pushpin: ホスト型仮想化

ホストOS上で、各サーバを仮想的に構築する。

**【Provider例】**

VMware Workstation、Oracle VM VirtualBox

![ホスト型仮想化](https://user-images.githubusercontent.com/42175286/60386396-3afbd080-9acf-11e9-9094-f61aa839dc04.png)



### :pushpin: ハイパーバイザー型仮想化

BIOSから起動したハイパーバイザー上で、各サーバを仮想的に構築する（※ホストOSは用いない）。

**【Provider例】**

VMware vSphere Hypervisor、Xen、KVM

![ハイパーバイザー型仮想化](https://user-images.githubusercontent.com/42175286/60386395-3afbd080-9acf-11e9-9fbe-6287753cb43a.png)



### :pushpin: コンテナ型仮想化

ホストOS上で、サーバではなく、サーバとしての機能を持つコンテナを仮想的に構築する。カーネルのリソースを分割できるNamespace（PID namespace、Network namespace、UID namespace）とControl Groupsを用いて、単一のOS上に独立したコンテナを構築する。

**【Provider例】**

Docker、LXC、OpenVZ

![コンテナ型仮想化](https://user-images.githubusercontent.com/42175286/60386394-3afbd080-9acf-11e9-96fd-321a88dbadc5.png)



## 03-02. 各仮想化のパフォーマンスの比較

### :pushpin: 起動速度の違い

ホスト型とハイパーバイザ型では、ハードウェア（CPU、メモリ、ハードディスク）とゲストOSを仮想化することが必要である。一方で、コンテナ型では、ハードウェアとゲストOSの仮想化は行わず、namespaceを用いてコンテナを構成するため、その分起動が速い。

![サーバ仮想化](https://user-images.githubusercontent.com/42175286/60386143-57e2d480-9acc-11e9-88b7-99a566346aba.png)



### :pushpin: 処理速度の違い

ゲストOS上のアプリを操作する場合、ホスト型とハイパーバイザ型では、ハードウェアやハイパーバイザーを経由する必要がある。この分だけ、時間（Overhead）を要する。一方で、コンテナ型では、各コンテナがホストOSとカーネルを共有するため、Overheadが小さい。

![仮想化](https://user-images.githubusercontent.com/42175286/60386143-57e2d480-9acc-11e9-88b7-99a566346aba.png)

- **Overheadの比較**

sysbenchというベンチマークツールを用いて、CPU・メモリ・ファイルI/Oに着目し、物理マシン・コンテナ型仮想化（Docker）・ホスト型仮想化（VirtualBox）のパフォーマンスを比較。

![各仮想化の比較](https://user-images.githubusercontent.com/42175286/60386476-27049e80-9ad0-11e9-92d8-76eed8927392.png)



## 03-03. 仮想サーバの構築

![Vagrantの仕組み_オリジナル](https://user-images.githubusercontent.com/42175286/60393574-b18de200-9b52-11e9-803d-ef44d6e50b08.png)



### :pushpin: VagrantによるProviderとProvisionerの操作


ProviderとProvisionerを操作し、仮想サーバの構築、ソフトウェアのインストール、を自動化するソフトウェア。チームメンバーが別々に仮想サーバを構築する場合、ProviderとProvisionerの処理によって作られる仮想サーバの環境に、違いが生じてしまう。Vagrantを使う場合、ProviderとProvisionerによる処理方法は、Vagrantfileに記述されている。このために、Vagrantを用いれば、チームメンバーが同じソフトウェアの下で、仮想サーバを構築し、ソフトウェアをインストールすることができる。サーバの情報は、ENVファイルで以下の様に管理する。

```yaml
#=======================================
# Webサーバ情報
#=======================================
WEB_HOST="XXX.X.X.X"

#=======================================
# データベースサーバ情報
#=======================================
DB_HOST="YYY.Y.Y.Y"
DB_NAME="example"
DB_USER="hiroki"
DB_PASSWORD="12345"
```

- **```vagrant```コマンド**

|                        | コマンド                    |
| :--------------------: | --------------------------- |
|     **サーバ起動**     | ```vagrant up```            |
|     **サーバ停止**     | ```vagrant halt```          |
|    **リモート接続**    | ```vagrant ssh```           |
| **起動中サーバの一覧** | ```vagrant global-status``` |



### :pushpin: Providerによる仮想サーバの構築

基本ソフトウェアにおける制御プログラムや一連のハードウェアを仮想的に構築する。構築方法の違いによって、『ホスト型』、『ハイパーバイザ型』に分類できる。



### :pushpin: Provisionerによるソフトウェアのインストール

Providerによって構築された仮想サーバに、Web開発のためのソフトウェアをインストールするソフトウェア。具体的には、プログラミング言語やファイアウォールをインストールする。



## 03-04. コンテナの構築

### :pushpin: Dockerクライアントによるコンテナの操作

![Dockerアーキテクチャ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Dockerアーキテクチャ.png)

- **```docker```コマンド**

|                                    | コマンド                                       |
| :--------------------------------: | ---------------------------------------------- |
|        **イメージのビルド**        | ```docker-compose build```                     |
| **イメージからコンテナ構築と起動** | ```docker-compose up -d```                     |
|          **コンテナ起動**          | ```docker start```                             |
|          **コンテナ停止**          | ```docker stop```                              |
|          **リモート接続**          | ```winpty docker exec -it {コンテナ名} bash``` |
|      **起動中コンテナの一覧**      | ```docker container ls```                      |



### :pushpin: Dockerホスト

- **Dockerデーモン**

Dockerデーモンを経由して、コンテナの構築、ソフトウェアインストール、コンテナの操作を行う。

- **コンテナ**

- **イメージ**

コンテナにインストールするソフトウェアのテンプレートこと。チーム開発では、共有されたイメージを元に、同じ環境設定が行われたコンテナを構築することができる。

ngnixイメージを探したい時、

|                                  | コマンド                         |
| -------------------------------- | -------------------------------- |
| イメージの検索                   | ```docker search {イメージ名}``` |
| イメージのインストール           | ```docker pull {イメージ名}```   |
| インストールされたイメージの確認 | ```docker images```              |

以下に、イメージのセット例を示す。

| インストールするべきソフトウェア | ソフトウェアのイメージ |
| :------------------------------: | ---------------------- |
|              **OS**              | CentOS                 |
|        **NoSQL（非RDB）**        | Redis                  |
|            **RDBMS**             | MySQL                  |
|    **Webサーバソフトウェア**     | Nginx                  |
|     **APサーバソフトウェア**     | PHP-FPM                |
|   **メールサーバソフトウェア**   | MailDev                |



### :pushpin: レジストリ



### :pushpin: コンテナを操作するまでの手順

![Dockerfileの作成からコンテナ構築までの手順](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Dockerfileの作成からコンテナ構築までの手順.png)



### :pushpin: Dockerfileによるイメージのインストールと設定

各Dockerイメージのインストールと設定に必要な一連のコマンドが記述された実行ファイル。Dockerfileを用いることで、以下のようなメリットがある。

![Dockerfileのメリット](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/Dockerfileのメリット.png)



### :pushpin: Docker Composeによるイメージのビルド、コンテナの構築、コンテナの起動

インストールされたDockerイメージビルド、コンテナの構築、コンテナの起動、を行うための管理ツール。Docker Composerでは、各コンテナを動かすための設定項目をServiceと呼んでいる。

|  設定項目   |                        意味                         |
| :---------: | :-------------------------------------------------: |
|    build    |                Dockerfileの相対パス                 |
|    ports    | コンテナで開放するポート番号（※ホスト側はランダム） |
|   volumes   |       マウントするディレクトリ間のマッピング        |
| environment |                    DBの環境変数                     |
| depends_on  |               コンテナが起動する順番                |
|  networks   |                         ???                         |
