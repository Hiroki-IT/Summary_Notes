# 01-01. データベースとは

### ◆ 関係データベース

現在、主流になっているデータベース

- **MariaDBのデータベース**
- **MySQLのデータベース**
- **PostgreSQLのデータベース**
- **Amazon Aurora**



### ◆ DBMS（データベース管理システム）

![DBMS](C:\Projects\tech-notebook\markdown\image\DBMS.jpg)

- **MariaDB**
- **MySQL**
- **PostgreSQL**
- **Amazon RDS：Amazon Relational Database Service**





### ◆ データベースエンジン

- **InnoDB**





# 01-02. データベースの設計

### ◆ **UMLによる設計**

16章を参照。Squidの設計図では、UMLとER図を組み合わせている。



### ◆ **ER図による設計：Entity Relation Diagram**

16章を参照。Squidの設計図では、UMLとER図を組み合わせている。



# 01-03. テーブルの作成

### ◆ 主キー

テーブルの中で、Rowデータを一意に特定できる値を『主キー』の値と呼ぶ。

![主キー](C:\Projects\tech-notebook\markdown\image\主キー.jpg)



### ◆ データを追加するあるいは削除する場合の注意点

データを追加するあるいは削除する場合、カラムではなく、レコードの増減を行う。カラムの増減の処理には時間がかかる。一方で、レコードの増減の処理には時間がかからない。

![カラムの増減は✖、レコードの増減は〇](C:\Projects\tech-notebook\markdown\image\カラムの増減は✖、レコードの増減は〇-1.png)

**【具体例】**

賞与を年1回から、2回・3回と変える場合、主キーを繰り返し、新しく賞与区分と金額区分を作る。

![カラムの増減は✖、レコードの増減は〇-2](C:\Projects\tech-notebook\markdown\image\カラムの増減は✖、レコードの増減は〇-2.png)



### ◆ 非正規形の正規化（最適なカラム設計）

繰り返し要素のある表を『正規形』、その逆を『非正規形』という。非正規形の表から、他と連動するカラムを独立させ、正規形の表に変更することを『正規化』という。

**【具体例1】**

まず、主キーが受注Noと商品IDの2つであることを確認。

1. **エクセルで表を作成**

   エクセルで作られた以下の表があると仮定。

![非正規形](C:\Projects\tech-notebook\markdown\image\非正規形.png)

2. **第一正規化（繰り返し要素の排除）**

   レコードを1つずつに分割。

   ![第一正規形](C:\Projects\tech-notebook\markdown\image\第一正規形.png)

3. **第二正規化（主キーの関数従属性を排除）**

   主キーと特定のカラムが連動する（関数従属性がある）場合、カラムを左表として独立させる。今回、主キーが2つあるので、まず受注Noから関数従属性を排除していく。受注Noと他3カラムが連動しており、左表として独立させる。主キーと連動していたカラムを除いたものを右表とする。また、主キーが重複するローを削除する。

   ![第二正規形-1](C:\Projects\tech-notebook\markdown\image\第二正規形-1.png)

   次に、商品IDの関数従属性を排除していく。商品IDと他2カラムに関数従属性があり、左表として独立させる。主キーと連動していたカラムを除いたものを右表とする。また、主キーが重複するローを削除する。これで、主キーの関数従属性の排除は終了。

   ![第二正規形-2](C:\Projects\tech-notebook\markdown\image\第二正規形-2.png)

   ![第二正規形-3](C:\Projects\tech-notebook\markdown\image\第二正規形-3.png)

4. **第三正規化（主キー以外のカラムの関数従属性を排除）**

   次に主キー以外のカラムの関係従属性を排除していく。上記で独立させた3つの表のうち、一番左の表で、顧客IDと顧客名に関数従属性があるので、顧客IDを新しい主キーに設定し、左表として独立させる。主キーと連動していたカラムを除いたものを右表とする。

![第三正規形](C:\Projects\tech-notebook\markdown\image\第三正規形-1.png)

![第三正規形-2](C:\Projects\tech-notebook\markdown\image\第三正規形-2.png)

5. **まとめ**

   主キーの関係従属性の排除によって、受注表、商品表、数量表に分割できた。また、主キー以外の関係従属性の排除によって、顧客IDを新しい主キーとした顧客表に分割できた。

![正規化後にどんな表ができるのか](C:\Projects\tech-notebook\markdown\image\正規化後にどんな表ができるのか.png)

**【具体例2】**

1. **エクセルで表を作成**

   以下のような表の場合、行を分割し、異なる表と見なす。

![非正規形-2](C:\Projects\tech-notebook\markdown\image\非正規形-2.png)

2. **第一正規化（繰り返し要素の排除）**

   ![第一正規形-2](C:\Projects\tech-notebook\markdown\image\第一正規形-2.png)



# 02-01. データベースに必要な機能

### ◆ ACID特性

トランザクションを実現するためには、以下の４つの機能が必要である。

- **Atomicity**

  コミットメント制御によって実装される。

- **Consistency** 

  トランザクションの前後でデータ排他制御によって実装される。

- **Isolation** 

  排他制御によって実装される。

- **Durability** 

  障害回復制御によって実装される。



# 02-02. コミットメント制御と障害回復制御

### ◆ データベース操作の全体像

![コミットメント制御](C:\Projects\tech-notebook\markdown\image\コミットメント制御.jpg)

**【実装例】**

```PHP
try{
    // データベースと接続。
    $db = getDb();

    // 例外処理を有効化。
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // トランザクションを開始。
    $db->beginTransaction();
    // いくつかのSQLが実行される。※もし失敗した場合、ERRMODE_EXCEPTIONを実行。
    $db->exec("INSERT INTO movie(title, price) VALUES('ハリポタ', 2000)")
    $db->exec("INSERT INTO movie(title, price) VALUES('シスター', 2000)")
   
    // トランザクション内の一連のステートメントが成功したら、トランザクションをコミット。
    $db->commit();

} catch{
	// 例外が発生したらロールバックし、エラーメッセージを出力。
	$db->rollBack();
	print "失敗しました。：{$e->getMessage()}"
}  
```

### ◆ 更新前ログのログファイルへの書き込み



### ◆ コミットによる更新後ログのログファイルへの書き込み

- **コミット**

トランザクション内の一連のステートメントをディスク上のログファイルに更新後ログを書き込む。

- **二相コミット**

コミットを以下の二つの段階に分けて行うこと。ACIDのうち、原子性と一貫性を実装している。

1. 他のサイトに更新可能かどうかを確認。
2. 全サイトからの合意が得られた場合に更新を確定。



### ◆ チェックポイントにおけるディスク上のデータファイルへの書き込み

トランザクションの終了後、DBMSは、処理速度を高めるために、ログファイルの更新後ログをいったんメモリ上で管理する。

![DBMSによるメモリとディスクの使い分け](C:\Projects\tech-notebook\markdown\image\DBMSによるメモリとディスクの使い分け.jpg)

そして、チェックポイントで、ログファイルの更新後ログをディスク上のデータファイルに反映させる。この時、チェックポイントは、自動実行または手動実行で作成する。

![トランザクション](C:\Projects\tech-notebook\markdown\image\トランザクション.jpg)



### ◆ システム障害からの回復

DBMSやOSのトラブル等によりシステム全体が停止する障害のこと。

![障害回復機能](C:\Projects\tech-notebook\markdown\image\システム障害の障害回復機能.jpg)

- **ロールバック**

障害によって、トランザクション内の一連のステートメントがすべて実行されなかった場合に、ログファイルの更新前ログを用いて、トランザクションの開始前の状態に戻す。

- **ロールフォワード**

障害によって、トランザクションの終了後に一連のステートメントの更新結果がディスクに反映されなかった場合に、ログファイルの更新後ログを用いて、ディスク上のデータファイルに更新結果を反映させる。

**【具体例】**

『a』の値を更新するステートメントを含むトランザクションの後に、システムが異常終了した場合、ログファイルの更新後ログ『a = 5』を用いて、ディスク上のデータファイルに更新結果を反映させる。（ロールフォワード）

『b』の値を更新するステートメントを含むトランザクションの途中に、システムが異常終了した場合、ログファイルの更新前ログ『b = 1』を用いて、障害発生前の状態に戻す。（ロールバック）



### ◆ 媒体障害からの回復

データベースの情報が格納された物理ディスクの障害のこと。ディスクを初期化／交換した後、バックアップファイルからデータベースを修復し、ログファイルの更新後ログ『a = 5』『b = 1』を用いて、修復できる限りロールフォワードを行う。

![媒体障害の障害回復機能](C:\Projects\tech-notebook\markdown\image\媒体障害の障害回復機能.jpg)

**【具体例】**

バックアップファイルの実際のコード

```PHP
-- --------------------------------------------------------
-- Host:                         xxxxx
-- Server version:               10.1.38-MariaDB - mariadb.org binary distribution
-- Server OS:                    Win64
-- HeidiSQL Version:             10.2.0.5611
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!50503 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

# データベース作成
-- Dumping database structure for kizukeba_pronami_php
CREATE DATABASE IF NOT EXISTS `kizukeba_pronami_php` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */;
USE `kizukeba_pronami_php`;

# テーブルのデータ型を指定
-- Dumping structure for table kizukeba_pronami_php.mst_staff
CREATE TABLE IF NOT EXISTS `mst_staff` (
  `code` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(15) COLLATE utf8_unicode_ci NOT NULL,
  `password` varchar(32) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`code`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

# データを作成
-- Dumping data for table kizukeba_pronami_php.mst_staff: ~8 rows (approximately)
/*!40000 ALTER TABLE `mst_staff` DISABLE KEYS */;
INSERT INTO `mst_staff` (`code`, `name`, `password`) VALUES
	(1, '秦基博', 'xxxxxxx'),
	(2, '藤原基央', 'xxxxxxx');
/*!40000 ALTER TABLE `mst_staff` ENABLE KEYS */;

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;

```



# 02-03. 排他制御

### ◆ なぜ排他制御が必要か

![排他制御-1](C:\Projects\tech-notebook\markdown\image\排他制御-1.png)

- **排他制御を行った結果**

  ![排他制御-2](C:\Projects\tech-notebook\markdown\image\排他制御-2.png)

  

### ◆ 排他制御におけるロックの種類

![排他制御-3](C:\Projects\tech-notebook\markdown\image\排他制御-3.gif)

-  **共有ロック**

CRUDのRead以外の操作を実行不可能にする。データのRead時に、他者によってUpdateされたくない場合に用いる。「共有」の名の通り、共有ロックされているデータに対して、他の人も共有ロックを行うことができる。

- **専有ロック**

CRUDの全ての操作を実行不可能にする。データのUpdate時に、他者によってUpdateもReadもされたくない場合に用いる。



### ◆ ロックの粒度

![ロックの粒度](C:\Projects\tech-notebook\markdown\image\ロックの粒度-1.png)

DB ＞ テーブル ＞ レコード ＞ カラム の順に、粒度は大きい。ロックの粒度が細かければ、トランザクションの同時実行性が高くなって効率は向上する（複数の人がDBに対して作業できる）。しかし、ロックの粒度を細かくすればするほど、それだけデータベース管理システムのCPU負荷は大きくなる。

![ロックの粒度-2](C:\Projects\tech-notebook\markdown\image\ロックの粒度-2.jpg)



### ◆ デッドロック現象

複数のトランザクションが、互いに他者が使いたいデータをロックしてしまい、お互いのロック解除を待ち続ける状態のこと。もう一方のレコードのロックが解除されないと、自身のレコードのロックを解除できない時、トランザクションが停止すること。

- **共有ロックしたデータを共有ロック**
- **共有ロックしたデータを専有ロック**
- **専有ロックしたデータを共有ロック**
- **専有ロックしたデータを専有ロック**

![デッドロック](C:\Projects\tech-notebook\markdown\image\デッドロック.gif)



# 03-01. createによるテーブルの作成

### ◆ 制約

レコードに挿入される値のデータ型を指定しておくことによって、データ型不一致やNullのための例外処理を実装しなくてもよくなる。

```PHP
// 注文テーブル作成
CREATE TABLE order_data (

    // PRIMARY KEY制約
    order_id INT(10) PRIMARY KEY COMMENT '注文ID',

    // NOT NULL制約
    order_kbn INT(3) NOT NULL COMMENT '注文区分',
    system_create_date_time DATETIME NOT NULL COMMENT 'システム登録日時',
    system_update_date_time DATETIME NOT NULL COMMENT 'システム更新日時',
    delete_flg INT(1) DEFAULT 0 NOT NULL COMMENT '0：通常、1：削除済',
    
    // 参照制約キー
    FOREIGN KEY order_kbn REFERENCES order_kbn_data
)
```

- **Foreign key（外部キー）と参照制約**

複数のテーブルを関連付けるために用いられるカラムのことをForeign key（外部キー）という。外部キーの参照先のテーブルには、外部キーの値と同じ値のカラムが存在していなければならない（参照制約）。参照制約を行うと、以下の2つが起こる。（1）親テーブルに存在しない値は、子テーブルに登録できない。（2）親テーブルで参照される値は、子テーブルからは削除できない。

![外部キー](C:\Projects\tech-notebook\markdown\image\外部キー.png)



### ◆ view

```

```



### ◆ stored procedure

あらかじめ一連のSQL文をデータベースに格納しておき、Call文で呼び出す方式。

![p325](C:\Projects\tech-notebook\markdown\image\p325.gif)

**【実装例】**

```PHP
// PROCEDUREを作成し、データベースへ格納しておく。
CREATE PROCEDURE SelectContact AS　
  SELECT CustomerID, CompanyName, ContactName, Phone
  FROM Customers
```

```PHP
// PROCEDUREを実行
EXEC SelectContact
```



# 03-02. selectによるデータセットの取得

### ◆ 実装例で用いた略号

**C**：column（列）

**R**：record（行）

**T**：table



### ◆ SQLの処理の順番

```PHP
from => join => where => group by => having => select => order by
```



### ◆ whereあるいはjoinによる内部結合

基本情報技術者試験では、内部結合（A∩B）しか出題されない。

- **``LEFT JOIN``で起こること**

『users』テーブルと『items』テーブルの商品IDが一致しているデータと、元となる『users』テーブルにしか存在しないデータが、セットで取得される。

![LEFT_JOIN](C:\Projects\tech-notebook\markdown\image\LEFT_JOIN.png)

- **内部結合に```where```を用いる場合**

2つの```where```文が、```AND```で結びつけられている時、まず一つ目の```where```を満たすレコードを取得した後、取得したレコードの中から、二つ目の```where```を満たすレコードを取得する。

```PHP
// 『カラム』を指定
select C,
	// 複数の表を指定
	from T1, T2, T3
	// まず、1つ目のフィールドと2つ目のフィールドが同じレコードを取得。
	where R1 = R2 and  
	// 次に、上記で取得したレコードのうち、次の条件も満たすレコードのみを取得。
	R2 = R3  
```

- **内部結合に```inner join on```を用いる場合（本試験では出題されない）**

```PHP
//『カラム』を指定
select C,
	// 複数の表を指定
	from T1  
	inner join T2
		// 2つ目の表の『レコード』と照合
		on T1.C1 = T2.C2  
	inner join T3
		// 3つ目の表の『レコード』と照合
    	on T1.C1 = T3.C3  
```

- **ベン図で内部結合と外部結合を理解しよう**

![内部結合のベン図](C:\Projects\tech-notebook\markdown\image\内部結合のベン図.jpg)



### ◆ 集合関数まとめ

- **sum()**

```PHP
// 指定したカラムで、『フィールド』の合計を取得
select sum(C)  
	from T;
```

- **avg()**

```PHP
// 指定したカラムで、『フィールド』の平均値を取得
select avg(C)  
	from T;
```

- **min()**

```PHP
// 指定したカラムで、『フィールド』の最小値を取得
select min(C)
	from T;
```

- **max()**

```PHP
// 指定したカラムで、『フィールド』の最大値を取得
select max(C)
	from T;
```

- **count()**

```PHP
// 指定したカラムで、『フィールド』の個数を取得
select count(C)
	from T;
```

**※消去法の小技：集合関数を入れ子状にはできない**

```PHP
// 集合関数を集合関数の中に入れ子状にすることはできない。
select avg(sum(C))
	from T;
```

```PHP
// 指定したカラムで、値無しも含む『フィールド』を取得
select count(*)
	from T;
```

```PHP
// 指定したカラムで、値無しを除いた『フィールド』を取得
select count(C);

// 上に同じ
select count(all C);
```

```PHP
// 指定したカラムで、重複した『フィールド』を除く全ての『フィールド』を取得 
select count(distinct C);
```



### ◆ in

**【IN句を使用しなかった場合】**

```PHP
SELECT * FROM fruit WHERE name = "みかん" OR name = "りんご";
```

**【IN句を使用した場合】**

```PHP
SELECT * FROM fruit WHERE name IN("みかん","りんご");
```



### ◆ group by

**※消去法の小技：```group by``` のカラム引数は、```select```のカラムと同じでなければならない**

```PHP
select C
	from T
    // 指定したカラムで、各グループのフィールドを集計
	group by C;
```



### ◆ having

```group by```で集計した結果から、```having```で『フィールド』を取得。

```PHP
select C
	from T
	group by C
    // 集計値が２以上の『フィールド』を取得
	having count(*) >= 2; 
```

※以下の場合、```group by + having```を使っても、```where```を使っても、同じ出力結果になる。

```PHP
select C
	from T
	group by C
	having R;
```

```PHP
select C
	from T
	where R
	group by C;
```



### ◆ sub-query

掛け算と同様に、括弧内から先に処理を行う。

```PHP
// Main-query
select * from T
    // Sub-query
	where C != (select max(C) from T);
```



### ◆ inとany

- **in**

  指定した値と同じ『フィールド』を取得

```PHP
select * from T
    // 指定したカラムで、指定した値の『フィールド』を取得
	where C in (xxx, xxx, ...);
```

```PHP
select * from T
	// 指定したカラムで、指定した値以外の『フィールド』を取得
	where C not in (R1, R2, ...);
```

```PHP
select * from T
	// フィールドを指定の値として用いる
	where C not in (
		// 指定したカラムで、『フィールド』を取得
		select C from T where R >= 160);
```

- **any**

  書き方が異なるだけで、```in```と同じ出力

```PHP
select * from T
	where C = any(xxx, xxx, xxx);
```



### ◆ view

ビューとはある表の特定のカラムや指定した条件に合致するレコードなどを取り出した仮想の表。また、複数の表を結合したビューを作成できる。ビューを作成することによりユーザに必要最小限のカラムやレコードのみにアクセスさせる事ができ、また結合条件を指定しなくても既に結合された表にアクセスできる。
⇒よくわからん…

```PHP
create view T as
	select * from ...;
```



### ◆ wildcard

```PHP
select * from T
	// 任意の文字（文字無しも含まれる）
	where C like '%営業';
```

```PHP
select * from T
	// 任意の一文字
	where C like '_営業';
```



### ◆ between

```PHP
select * from T
	// 指定したカラムで、1以上10以下の『フィールド』を取得
	between 1 and 10;
```



### ◆ prepared statement





# 03-03. fetchによるデータ行の取得

DBで取得したデータをプログラムに一度に全て送信してしまうと、プログラム側のメモリを圧迫してしまう。そこで、fetchで少しずつ取得する。

**【スクラッチ開発による実装例】**

```PHP
$sql = "SELECT * FROM doraemon_characters";
$stmt = $dbh->prepare($sql);
$stmt->execute();


// 全てのデータ行を取得
$data = $stmt->fetchAll();
print_r($data);


// カラム名と値の連想配列として取得できる。
Array
(
	[0] => Array
	(
        [id] => 1
        [name] => のび太
        [gender] => man
        [type] => human
	)
    [1] => Array
    (
        [id] => 2
        [name] => ドラえもん
        [gender] => man
        [type] => robot
    )
)
```

**【フレームワークによる実装例（Symfony）】**

```getConnection()```を起点として、返り値から繰り返しメソッドを取得し、```fetchAll()```で、テーブルのクエリ名をキーとした連想配列が返される。

```PHP
// select文やパラメータを設定し、fetchAllへメソッドチェーン
getConnection()->executeQuery($query, $params, $types, $qcp)->fetchAll();


// カラム名と値の連想配列として取得できる。
Array　= (
　　[kbn_name] => レッド 
　　[kbn_value] => 2
　　[quantity] => 50
)
```



# 03-04. insertによるデータ行の入力

**【スクラッチ開発による実装例】**

```PHP
// $_POSTを用いて、送信されたpostメソッドのリクエストを受け取り、属性から各値を取得
$staff_name = $_POST['name'];
$staff_pass = $_POST['pass'];


// HTMLとして変数の内容を出力する際、「<」「>」などの特殊文字をエスケープ（無害化）
$staff_name = htmlspecialchars($staff_name, ENT_QUOTES, 'UTF-8');
$staff_pass = htmlspecialchars($staff_pass, ENT_QUOTES, 'UTF-8');


// データベースと接続（イコールの間にスペースを入れるとエラーになる）
$dsn = 'mysql:dbname=kizukeba_pronami_php;
host=kizukebapronamiphp
charaset=UTF-8';
$user = 'root';
$password = '';
$dbh = new PDO($dsn, $user, $password);
$dbh->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);


// データベースに対してCREATE
$sql='INSERT INTO mst_staff (name,password) VALUES (?,?)';
$stmt = $dbh->prepare($sql);


// 配列に値を格納（格納する値の順番と、SQLでの引数の順番は、合わせる必要がある）
$data[] = $staff_name;
$data[] = $staff_pass;


// SQLを実行
$stmt->execute($data);


// データベースとの接続を切断
$dbh = null;
```



# 03-05. migrationによるデータベースの更新

マイグレーションファイルと呼ばれるスクリプトファイルを作成し、テーブルの新規作成やカラムの追加はこのスクリプトファイルに記述していく。

1. 誰かが以下のMigrationファイルをmasterにPush
2. Migrationファイルをローカル環境にPull
3. データベース更新コマンドを実行し、ローカル環境のDBスキーマとデータを更新

```PHP
namespace Migration

class ItemQuery
{
	public static function insert()
	{
		return "INSERT INTO item_table VALUES(1, '商品A', 1000, '2019-07-24 07:07:07');"
	}
}
```



# 04. レコードのマッチング（突き合わせ）

### ◆ マッチング（突き合わせ）処理とは

ビジネスの基盤となるマスタデータ（商品データ、取引先データなど）と、日々更新されるトランザクションデータ（販売履歴、入金履歴など）を突き合わせ、新しいデータを作成する処理のこと。

![マッチング処理における突き合わせ_1](C:\Projects\tech-notebook\markdown\image\マッチング処理における突き合わせ_1.PNG)



### ◆ マッチング処理の具体例

**【実用例】**

生命保険会社では、契約データを契約マスタテーブルで、また契約データの日々の変更点（異動事由）を異動トランザクションテーブルで管理している。毎日、契約マスタテーブルと異動トランザクションテーブルにおける前日レコードをマッチングし、各契約の異動事由に応じて、新契約マスタテーブルに変更後契約データとして追加する。

![マッチング処理における突き合わせ_2](C:\Projects\tech-notebook\markdown\image\マッチング処理における突き合わせ_2.PNG)

前処理として、マスタデータとトランザクションデータで同じ識別子を持たせ、両方を昇順で並び替える。

1. マスタデータの一行目と、トランザクションデータの一行目の識別子を突き合わせる。『マスタデータ＝トランザクションデータ』の時、そのレコードを新しいデータとして出力する。続けて、マスタデータの一行目と、トランザクションデータの二行目のレコードを突き合わせる。『マスタデータ≠トランザクションデータ』になるまで、トランザクションのN行目のレコードを突き合わせる。
2. マスタデータの二行目と、トランザクションデータの二行目の識別子を突き合わせる。『マスタデータ＜トランザクションデータ』になる。
3. マスタデータの三行目と、トランザクションデータの二行目の識別子を突き合わせる。『マスタデータ＝トランザクションデータ』の時、そのレコードを新しいデータとして出力する。