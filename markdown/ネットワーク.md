# 01. ネットワークの全体像

### ◆ インターネット、WAN、LAN

ネットワークには、『インターネット』『WAN』『LAN』がある。家庭内LAN、学内LAN、企業内LAN、企業WANなど、さまざまなネットワークがあり、インターネットは、それぞれのネットワークを互いに接続しているネットワークである。

![インターネットとWANとLAN](C:\Projects\tech-notebook\markdown\image\インターネットとWANとLAN.png)



### ◆ WAN、LANの具体例

例えば、LANとしてEthernet、WANとしてデジタル専用線を用いる。

![WAN、LANの具体例](C:\Projects\tech-notebook\markdown\image\WAN、LANの具体例.png)



### ◆ WANの種類と歴史

![WANの歴史](C:\Projects\tech-notebook\markdown\image\WANの種類と歴史.png)



### ◆ グローバルネットワークとプライベートネットワーク

ルータを境に、プライベートネットワークとグローバルネットワークに分けられる。ややこしいが、ルータにはグローバルIPアドレスが割り当てられている。

![グローバルネットワークとプライベートネットワーク](C:\Projects\tech-notebook\markdown\image\グローバルネットワークとプライベートネットワーク.PNG)



### ◆ プライベートネットワークにおけるセグメント

プライベートネットワークは、外部ネットワーク、非武装地帯、内部ネットワークに分類される。

- **非武装地帯に設置するべきサーバの種類**

攻撃の影響が内部ネットワークに広がる可能性を防ぐために、外部から直接リクエストを受ける、『DNSサーバ』『Proxyサーバ』『Webサーバ』『メールサーバ』は、非武装地帯に設置するべき。

- **内部ネットワークに設置するべきサーバの種類**

外部からリクエストを受けない『データベースサーバ』は、内部ネットワークに設置するべき。

![内部、DMZ、外部](C:\Projects\tech-notebook\markdown\image\内部、DMZ、外部.png)



### ◆ ネットワークにおけるデータ通信方法の種類

- **回線交換方式**

  少数対少数でデータ通信を行うため、送信時に、送信者と受信者の宛先情報は必要ない。

  ![回線交換方式](C:\Projects\tech-notebook\markdown\image\回線交換方式.png)

- **パケット交換方式**

  通信するデータをパケット化する。多数対多数でデータ通信を行うため、送信時に、送信者と受信者の宛先情報が必要になる。

  ![パケット交換方式](C:\Projects\tech-notebook\markdown\image\パケット交換方式.png)



# 02-01. OSI参照モデルとTCP階層モデル

### ◆ データの作成、ヘッダ情報追加、カプセル化

パケット交換方式におけるパケットのヘッダ情報は、パソコンの各概念層のプロトコルによって追加されていく。

![パケットの構造](C:\Projects\tech-notebook\markdown\image\パケットの構造.jpg)



### ◆ OSI参照モデルにおいて各概念層で追加されるヘッダ情報の内容

![OSI参照モデル](C:\Projects\tech-notebook\markdown\image\OSI参照モデル.png)



### ◆ プロトコルの分類と扱われる階層

TCP/IPモデルで用いられるプロトコルのうち、最も代表的な「TCP」と「IP」から名前をとって「TCP/IP」と名付けられた。プロトコルとしての暗号化技術である『セキュアプロトコル』は、赤色で示してある。

![セキュアプロトコル](C:\Projects\tech-notebook\markdown\image\セキュアプロトコル.png)



# 02-02. 【OSI】通信機器におけるヘッダ情報認識

### ◆ 各概念層の実際の通信機器の対応関係

![OSI参照モデルと通信機器.png](C:\Projects\tech-notebook\markdown\image\OSI参照モデルと通信機器.jpg)

- **ネットワーク層**

- **データリンク層**

- **物理層**

Network Interface Card（（例）LANアダプタ、LANボード、LANカード）、リピータ、LANケーブル



### ◆ 通信機器における各層のヘッダ情報の認識

送信元で作成されたパケットは、非カプセル化されながら、通信機器に認識される。

![OSI参照モデルと通信機器でのパケット認識.png](C:\Projects\tech-notebook\markdown\image\OSI参照モデルと通信機器でのパケット認識.jpg)



# 02-03. アプリケーション層におけるWWWコンテンツの作成

### ◆ プロトコルの分類と扱われる階層（再掲）

パケット交換方式におけるパケットのヘッダ情報は、パソコンの各概念層のプロトコルによって追加されていく。プロトコルとしての暗号化技術である『セキュアプロトコル』は、赤色で示してある。

![セキュアプロトコル](C:\Projects\tech-notebook\markdown\image\セキュアプロトコル.png)



### ◆ WebAPIの種類

HTTPの構造は、WebAPIの種類によって決まる。WebAPIには、『SOAP』と『REST』がある。

![SOAP API vs REST API](https://user-images.githubusercontent.com/42175286/59290202-fa205100-8cb2-11e9-9a16-8613a88403b4.png)



### ◆ SOAPにおけるメソッド

1999年にMicrosoft社などによって発表された。2000年前半には企業システムのWebサービス化とともに普及するかに思われたが、複雑な構造であったため次第に敬遠されるようになった。その後、簡単な構造のREST APIが好まれるようになった。

**【具体例】**

POSTメソッドによるリクエスト

![SOAP API](https://user-images.githubusercontent.com/42175286/59289616-6b5f0480-8cb1-11e9-987f-b1761c73fcf1.gif)



### ◆ RESTにおけるメソッド

![HTTPリクエストのメソッド](https://user-images.githubusercontent.com/42175286/56901644-9875a000-6ad3-11e9-93a1-a738b2e382ac.png)

- **GETメソッドによるリクエスト情報**  
  URL以降に、『/？～』付加してHTTPリクエストを送る方法。URLに情報が記述されるため、履歴で確認できてしまう。リクエスト情報は、以下の要素に分類できる。

1. リクエスト行
2. リクエストヘッダー：リクエストの詳細情報
3. メソッド：GET
4. リクエストの対象：ファイルへのパス
5. HTTPプロトコルのバージョン
6. User-Agent：ブラウザのバージョン情報等
7. Accept：ブラウザが想定する(利用可能な)MIMEのタイプ
8. Referer：遷移元のページ
9. Accept-Encoding：ブラウザがデコードできるエンコーディング形式
10. Accept-Language：ブラウザが想定する(利用可能な)言語

![GET送信時のHTTPリクエスト](https://user-images.githubusercontent.com/42175286/58061886-0ed95f80-7bb3-11e9-8998-f105a5e0ed40.png)

- **POSTメソッドによるリクエスト情報**  
  メッセージボディに記述してHTTPリクエストを送る方法。メッセージボディに情報が記述されるため、履歴では確認できない。リクエスト情報は、以下の要素に分類できる。

1. リクエスト行
2. リクエストヘッダー：リクエストの詳細情報
3. 空白行：ヘッダーとボディを分ける
4. ボディ：画面での入力内容が入っている
5. メソッド：POST
6. リクエストの対象：ファイルへのパス
7. HTTPプロトコルのバージョン

![POST送信時のHTTPリクエスト](https://user-images.githubusercontent.com/42175286/58061918-29abd400-7bb3-11e9-94d0-fd528901ba7c.png)

- **レスポンス情報** 

リクエスト情報は、以下の要素に分類できる。

1. HTTPステータス
2. レスポンスヘッダー：レスポンスの詳細情報がある
3. 空白行：ヘッダーとボディを分ける
4. ボディ：HTMLや画像等が入る
5. HTTPプロトコルのバージョン
6. ステータスコード：200はサーバーのWebシステム処理が成功したことを表す
7. Server：サーバーの名前とバージョン等です。
8. Content-Type：出力するMIMEタイプ

![HTTPリクエストに対するHTTPレスポンス](https://user-images.githubusercontent.com/42175286/58062092-fd448780-7bb3-11e9-8b33-e11595c4e1fc.PNG)



### ◆ HTTPステータスの種類

- **100番台：継続**
- **200番台：リクエスト成功**
- **300番台：リダイレクトに関するステータス**
- **400番台：リクエスト失敗**
- **500番台：サーバーエラー**



# 02-04. アプリケーション層におけるメールデータの作成

### ◆ プロトコルの分類と扱われる階層（再掲）

パケット交換方式におけるパケットのヘッダ情報は、パソコンの各概念層のプロトコルによって追加されていく。プロトコルとしての暗号化技術である『セキュアプロトコル』は、赤色で示してある。

![セキュアプロトコル](C:\Projects\tech-notebook\markdown\image\セキュアプロトコル.png)



### ◆ メール送信用プロトコル

- **SMTP AUTH：Simple Mail Transfer Protocol AUTHentication**

  メール送信にあたってユーザ認証の仕組みがないSMTPを拡張し、ユーザ認証機能を追加した仕様。




### ◆ メール受信用プロトコル

- **POP3：Post Official Protocol version 3**

  メールサーバに届いたメールを、受信機器にダウンロードし、受信機器で閲覧するプロトコル。メールの既読未読状況は、他の受信機器と共有される。
  
- **IMAP4：Internet Message Access Protocol version 3**

  メールサーバに届いたメールを、受信機器にダウンロードせず、メールサーバに置いたまま閲覧するプロトコル。メールの既読未読状況は、他の受信機器と共有されない。

  **【具体例】**
  
  GmailでPOPかIMAPを設定可能

![GmailでPOPorIMAPを設定](C:\Projects\tech-notebook\markdown\image\GmailでPOPかIMAPを設定.jpg)

- **APOP：Authenticated POP**

  メール受信の際に、チャレンジレスポンス方式の認証を行うことで平文の認証情報がネットワークに流れるのを防止するプロトコル

  

# 02-05. トランスポート層におけるヘッダ情報追加

### ◆ プロトコルの分類と扱われる階層（再掲）

パケット交換方式におけるパケットのヘッダ情報は、パソコンの各概念層のプロトコルによって追加されていく。プロトコルとしての暗号化技術である『セキュアプロトコル』は、赤色で示してある。

![セキュアプロトコル](C:\Projects\tech-notebook\markdown\image\セキュアプロトコル.png)



### ◆ レスポンスにおけるポート番号の識別の仕組み

![トランスポート層からアプリケーション層へのパケットの移動](C:\Projects\tech-notebook\markdown\image\トランスポート層からアプリケーション層へのパケットの移動.PNG)

まず、プライベートIPアドレスを用いて、レスポンス先のパソコンを識別する。その後、リクエスト時のポート番号を元にして、特定のアプリにレスポンスする。

**【具体例】**

Webページを見ながらメールアプリを起動している場合…

1. プロトコル『POP3』とポート番号『110』を指定して、メールアプリにレスポンス。

2. プロトコル『HTTP』とポート番号『80』を指定して、Webフロントにレスポンス。

3. プロトコル『DNS』とポート番号『53』を指定して、Webフロントにレスポンス。

   

![ポート番号](C:\Projects\tech-notebook\markdown\image\ポート番号.png)



### ◆ ポートスキャナ

ポートスキャナを用いることによって、各ポートにアクセスし、応答があるかどうかや、どのようなソフトウェアが応答するかを調べ、一覧表示することができる。



### ◆ ポート番号の種類

アプリには、種類ごとにポート番号が割り当てられている。

- **Well known ポート番号（0 ～ 1023）**

  IANA：Internet Assigned Numbers Authority（インターネット割当番号公社）によって管理されているポート番号。Webサーバがリクエストを受信する時、またレスポンスを送信する時に使用される。

  ![ポート番号とプロトコルの対応関係](C:\Projects\tech-notebook\markdown\image\ポート番号とプロトコルの対応関係.png)

- **登録済みポート番号（1024 ～ 49151）**

  IANAが登録申請を受けて公開しているポート番号。企業が作成した独自のアプリなどに対して割り当てられる。クライアントがリクエストを送信する時、またレスポンスを受信する時に使用される。

- **動的／非公式ポート番号（49152 ～ 65535）**

  自由に使用できるポート番号。クライアントがリクエストを送信する時、またレスポンスを受信する時に使用される。



# 02-06. インターネット層におけるヘッダ情報追加

### ◆ プロトコルの分類と扱われる階層（再掲）

パケット交換方式におけるパケットのヘッダ情報は、パソコンの各概念層のプロトコルによって追加されていく。プロトコルとしての暗号化技術である『セキュアプロトコル』は、赤色で示してある。

![セキュアプロトコル](C:\Projects\tech-notebook\markdown\image\セキュアプロトコル.png)



### ◆ IPパケットのヘッダ情報を用いた宛先認識

1. PC-Aは、構成したIPパケットをEthernetに乗せて、ルータAに送信。
2. ルータAは、IPパケットをデジタル専用線に乗せて、ルータBに送信。
3. ルータBは、構成したIPパケットをEthernetに乗せて、Webサーバに送信。

![ネットワークにおけるTCP_IPを用いたデータ通信](C:\Projects\tech-notebook\markdown\image\ネットワークにおけるTCP_IPを用いたデータ通信.png)



### ◆ IPv4アドレスの種類

- **プライベートIPアドレス**

  LAN内で使用される。異なるプライベートネットワーク間では、同じIPv4アドレスが存在する。プライベートｆは、『10.0.0.0 ～ 10.255.255.255』、『172.16.0.0 ～ 172.31.255.255』、『192.168.0.0 ～ 192.168.255.255』で表される。

- **グローバルIPアドレス**

  プロバイダが提供するIPv4アドレス。パブリックネットワーク内に同じIPv4アドレスは存在せず、Network Information Centerへの使用申請が必要。プライベートIPアドレスの番号でなければ、グローバルIPアドレスである。ルータには、グローバルIPアドレスが割り当てられている。

![プライベートIPアドレスとグローバルIPアドレス](C:\Projects\tech-notebook\markdown\image\プライベートIPアドレスとグローバルIPアドレス.png)



### ◆ IPv4アドレスのクラス

**【具体例】**

128.0.0.0は、クラス B

- **クラスA**
  上位8ビット部分が、10進表記で、0～127

- **クラスB**
  上位8ビット部分が、10進表記で、128～191

- **クラスC**
  上位8ビット部分が、10進表記で、192～223

- **クラスD**
  上位8ビット部分が、10進表記で、224～239

  

### ◆ URLとメールアドレスの構造

- **各部品の名称**

![URLと電子メールの構造](C:\Projects\tech-notebook\markdown\image\URLと電子メールの構造.png)

- **各部品の様々な組み合わせ**

![ホスト名とドメイン名の組み合わせの種類](C:\Projects\tech-notebook\markdown\image\ホスト名とドメイン名の組み合わせの種類.gif)



### ◆ 完全修飾ドメイン名とグローバルIPアドレスのマッピング

![IPアドレスと完全修飾ドメイン名のマッピング1（編集後）](C:\Projects\tech-notebook\markdown\image\IPアドレスと完全修飾ドメイン名のマッピング4.png)

例えば、外部WebサーバのグローバルIPアドレスが『203.142.205.139』であると知っている場合、URLのプロトコル部分以下を『203.142.205.139』としてリクエストすれば、外部Webサーバが提供するウェブサイトにアクセスできる。しかし、グローバルIPアドレスは数字の羅列であるため、人間には覚えにくい。そこで、グローバルIPアドレスの代わりに、完全修飾ドメイン名をURLの一部として用いる。

- **完全修飾ドメイン名の構造**

![ドメイン名の構造](C:\Projects\tech-notebook\markdown\image\ドメイン名の構造.PNG)



# 02-07. ルータの種類

### ◆ NAT：Network Address TranslationによるIPアドレスv4の変換

パケットのヘッダ情報におけるプライベートIPアドレスとグローバルIPアドレスを相互変換する機能。

- **プライベートIPアドレスからグローバルIPアドレスへの変換**

![プライベートからグローバルへのnat変換](C:\Projects\tech-notebook\markdown\image\プライベートからグローバルへのnat変換.png)

- **グローバルIPアドレスからプライベートIPアドレスへの変換**

![グローバルからプライベートへのnat変換](C:\Projects\tech-notebook\markdown\image\グローバルからプライベートへのnat変換.png)



### ◆ NAPT：Network Address Port Translationによるポート番号の変換

NATと同様にプライベートIPアドレスとグローバルIPアドレスの間を相互変換するだけでなく、ポート番号も変換する。

![napt変換](C:\Projects\tech-notebook\markdown\image\napt変換.png)



# 02-08. 名前解決の仕組み

### ◆ Proxyサーバの機能

- **代理リクエスト機能（セキュリティのノートも参照）**

代理でリクエストを送るフォワードプロキシサーバと、レスポンスを送るプロキシサーバに分類できる。

![フォワードプロキシサーバーとリバースプロキシサーバ](C:\Projects\tech-notebook\markdown\image\フォワードプロキシサーバーとリバースプロキシサーバ.png)

- **キャッシュ機能**

![プロキシサーバのキャッシュ機能](C:\Projects\tech-notebook\markdown\image\プロキシサーバのキャッシュ機能.png)



### ◆ Proxyサーバ（FwとRe）、DNSサーバ、Webサーバによる名前解決

![IPアドレスと完全修飾ドメイン名のマッピング3.png](C:\Projects\tech-notebook\markdown\image\IPアドレスと完全修飾ドメイン名のマッピング3.png)

- **（1）完全修飾ドメイン名に対応するIPアドレスのレスポンス**

1. クライアントPCは、完全修飾ドメイン名を、フォワードProxyサーバにリクエスト。
2. フォワードProxyサーバは、完全修飾ドメイン名を、リバースProxyサーバに代理リクエスト。
3. リバースProxyサーバは、完全修飾ドメイン名を、DNSサーバに代理リクエスト。
4. DNSサーバは、完全修飾ドメインにマッピングされるIPv4アドレスを取得し、リバースProxyサーバにレスポンス。
5. リバースProxyサーバは、IPv4アドレスを、フォワードProxyサーバに代理レスポンス。（※NATによるIPv4アドレスのネットワーク間変換が起こる）
6. フォワードProxyサーバは、IPv4アドレスを、クライアントPCに代理レスポンス。

- **（2）IPアドレスに対応するWebページのレスポンス**

1. クライアントPCは、レスポンスされたIPv4アドレスを基に、Webページを、リバースProxyサーバにリクエスト。
2. リバースProxyサーバは、Webページを、Webサーバに代理リクエスト。
3. Webサーバは、Webページを、リバースProxyサーバにレスポンス。
4. リバースProxyサーバは、Webページを、クライアントPCに代理レスポンス。

※上記の様に、リクエストとレスポンスが繰り返されるが、データ通信は光速なので、１秒もかからない。



### ◆ 外部Webサーバとのデータ通信に要する時間

ネットワークのデータグローバル光回線が用いられている。光は、30万km／秒であり、一周4万kmの地球を7.5周／秒できることからもわかるように、遠く離れた国にあるWebサーバであっても、データ通信に要する時間は、１秒にも満たない。



### ◆ サーバの処理能力向上の方法

- **スケールアップ ⇔ スケールダウン**

  サーバ自体のスペックをより高くすることで、サーバ当たりの処理能力を向上させる。その逆は、スケールダウン。

  ![スケールアップ](C:\Projects\tech-notebook\markdown\image\スケールアップ.png)

- **スケールアウト ⇔ スケールイン**

  サーバの台数を増やすことで、サーバ全体の処理能力を向上させる。その逆は、スケールイン。

  ![スケールアウト](C:\Projects\tech-notebook\markdown\image\スケールアウト.png)





# 02-09. システムの構成方法

### ◆ Dualシステム

同じ処理を行う2つのシステムからなるシステム構成のこと。随時、処理結果を照合する。いずれかが故障した場合、異常が発生したシステムを切り離し、残る片方で処理を続けることによって、故障を乗り切る。

![デュアルシステム](C:\Projects\tech-notebook\markdown\image\デュアルシステム.png)



### ◆ Duplexシステム

オンライン処理を行う主系システムと、バッチ処理を行う従系システムからなるシステム構成のこと。主系システムが故障した場合、主系システムのオンライン処理を従系システムに引き継ぎ、処理を続けることによって、故障を乗り切る。

![デュプレックスシステム](C:\Projects\tech-notebook\markdown\image\デュプレックスシステム.png)

従系システムの待機方法には２つの種類がある。

- **ホットスタンバイ**

  ![p613-1](C:\Projects\tech-notebook\markdown\image\p613-1.png)

- **コールドスタンバイ**

  ![p613-2](C:\Projects\tech-notebook\markdown\image\p613-2.png)



### ◆ システムの稼働率

並列システムの場合、両方の非稼働率をかけて、全体から引く。

**【具体例】**

１－(1－0.81) × (1－0.64) = 0.9316

![稼働率の計算](C:\Projects\tech-notebook\markdown\image\稼働率の計算.jpg)



# 03-01. サーバ仮想化とコンテナ仮想化

自身の開発環境でWebシステムやデータベースを動かしたい場合、まず、パソコン内にLinux環境のWebサーバやデータベースサーバなどの各物理サーバを仮想的に構築する。そして、自身のパソコンをクライアント、各仮想サーバをリクエスト先に見立てて、SSHプロトコルを用いてこれらのサーバにリモートログインし、操作する。仮想環境の構築方法にはいくつか種類がある。

### ◆ ホスト型仮想化

ホストOS上で、各サーバを仮想的に構築する。

**【Provider例】**

VMware Workstation、Oracle VM VirtualBox

![ホスト型仮想化](https://user-images.githubusercontent.com/42175286/60386396-3afbd080-9acf-11e9-9094-f61aa839dc04.png)



### ◆ ハイパーバイザー型仮想化

BIOSから起動したハイパーバイザー上で、各サーバを仮想的に構築する（※ホストOSは用いない）。

**【Provider例】**

VMware vSphere Hypervisor、Xen、KVM

![ハイパーバイザー型仮想化](https://user-images.githubusercontent.com/42175286/60386395-3afbd080-9acf-11e9-9fbe-6287753cb43a.png)



### ◆ コンテナ型仮想化

ホストOS上で、サーバではなく、サーバとしての機能を持つコンテナを仮想的に構築する。カーネルのリソースを分割できるNamespace（PID namespace、Network namespace、UID namespace）とControl Groupsを用いて、単一のOS上に独立したコンテナを構築する。

**【Provider例】**

Docker、LXC、OpenVZ

![コンテナ型仮想化](https://user-images.githubusercontent.com/42175286/60386394-3afbd080-9acf-11e9-96fd-321a88dbadc5.png)



# 03-02. 各仮想化のパフォーマンスの比較

### ◆ 起動速度の違い

ホスト型とハイパーバイザ型では、ハードウェア（CPU、メモリ、ハードディスク）とゲストOSを仮想化することが必要である。一方で、コンテナ型では、ハードウェアとゲストOSの仮想化は行わず、namespaceを用いてコンテナを構成するため、その分起動が速い。

![サーバ仮想化](https://user-images.githubusercontent.com/42175286/60386143-57e2d480-9acc-11e9-88b7-99a566346aba.png)



### ◆ 処理速度の違い

ゲストOS上のアプリを操作する場合、ホスト型とハイパーバイザ型では、ハードウェアやハイパーバイザーを経由する必要がある。この分だけ、時間（Overhead）を要する。一方で、コンテナ型では、各コンテナがホストOSとカーネルを共有するため、Overheadが小さい。

![仮想化](https://user-images.githubusercontent.com/42175286/60386143-57e2d480-9acc-11e9-88b7-99a566346aba.png)

- **Overheadの比較**

sysbenchというベンチマークツールを用いて、CPU・メモリ・ファイルI/Oに着目し、物理マシン・コンテナ型仮想化（Docker）・ホスト型仮想化（VirtualBox）のパフォーマンスを比較。

![各仮想化の比較](https://user-images.githubusercontent.com/42175286/60386476-27049e80-9ad0-11e9-92d8-76eed8927392.png)



# 03-03. Provider、Provisioner、Vagrantを用いた仮想環境の構築・環境設定・操作

![Vagrantの仕組み_オリジナル](https://user-images.githubusercontent.com/42175286/60393574-b18de200-9b52-11e9-803d-ef44d6e50b08.png)



### ◆ Provider

基本ソフトウェアにおける制御プログラムや一連のハードウェアを仮想的に構築する。構築方法の違いによって、『ホスト型』、『ハイパーバイザ型』、『コンテナ型』に分類できる。



### ◆ Provisioner

Providerによって構築された仮想サーバやコンテナに、Web開発のためのソフトウェアをインストールするアプリ。具体的には、基本ソフトウェアにおける汎用言語プログラムやファイアウォールをインストールする。



### ◆ Vagrant

ProviderとProvisionerによる仮想サーバやコンテナの構築・環境設定・操作を自動化するプログラム。チームメンバーが別々に仮想サーバを構築する場合、ProviderとProvisionerの環境設定に違いが生じてしまう。Vagrantを使う場合、仮想サーバやコンテナの環境設定はVagrantfileに記述されている。また、仮想サーバやコンテナの構築・操作はvagrant経由で行える。これらのために、Vagrantを用いれば、チームメンバーが同じ環境設定の下で、仮想サーバやコンテナを構築・操作することができる。サーバやコンテナの情報は、ENVファイルで以下の様に管理する。

```
#=======================================
# Webサーバ情報
#=======================================
WEB_HOST="XXX.X.X.X"

#=======================================
# データベースサーバ情報
#=======================================
DB_HOST="YYY.Y.Y.Y"
DB_NAME="example"
DB_USER="hiroki"
DB_PASSWORD="12345"
```



# 04-01. オンプレミスとクラウドコンピューティング

![Iaas、Paas、Saasの比較](C:\Projects\tech-notebook\markdown\image\Iaas、Paas、Saasの比較.JPG)

### ◆ On premise

自社の設備によって、システムを運用すること。



### ◆ Iaas：Infrastructure as a Service

​	**【Iaasアプリ例】**

Amazon Web Service、Google Cloud Platform、Microsoft Azure、IBM Cloud



### ◆ Paas：Platform as a Service

​	**【Paasアプリ例】**

Google App Engine、Windows Azure



### ◆ Saas：Software as a Service

従来はパッケージとして提供していたアプリケーションを、Webアプリケーションとして提供するサービスのこと。

**【Saasアプリ例】**

Google Apps（Google Map、Google Cloud、Google Calender など）



# 04-02. masterブランチ変更後の自動テスト

### ◆ Continuous Integratorにおける自動テスト

1. テスト駆動開発の基、テストディレクトリでテストプログラムを実装したうえで、新機能を設計実装する。

2. ツールが、GituHubから、テストプログラムを含むmasterブランチの状態を取得する。

3. ツールによって、テストサーバの仮想化やコンパイルを行い、テストプログラムを自動で実行する。

4. 結果を通知することも可能。

**【自動化ツールアプリ例】**

Circle CI、Jenkins

![継続的インテグレーション](C:\Projects\tech-notebook\markdown\image\継続的インテグレーション.png)



# 04-03. 自動テスト後のAWS仮想サーバへのデプロイ

### ◆ インスタンスへのデプロイにデプロイツールを用いる場合

本番環境（ここではクラウドWebサーバ）にGitをインストールして```pull```を行い、GitHubからデプロイサーバにmasterブランチの状態を取り込む。

![GitHub上のコードが本番環境にデプロイされるまで](C:\Projects\tech-notebook\markdown\image\GitHub上のコードが本番環境にデプロイされるまで.png)

デプロイ自動化ツール（例：Capistrano）をキックすることによって、デプロイサーバからAWSにおけるインスタンスやデータベースへデプロイが行われる。

![Capistranoを用いた自動デプロイ](C:\Projects\tech-notebook\markdown\image\Capistranoを用いた自動デプロイ.png)



### ◆ インスタンスへのデプロイにAWS CodeDeployを用いる場合

![CodeDeployを用いた自動デプロイ](C:\Projects\tech-notebook\markdown\image\CodeDeployを用いた自動デプロイ.png)



# 04-04. AWSによるWebサービスのリリース

AWSから、グローバルIPアドレスと完全修飾ドメイン名が提供され、Webサービスがリリースされる。

**【クラウドデザイン例】**

以下のデザイン例では、Dualシステムが採用されている。

![AWSのクラウドデザイン一例](C:\Projects\tech-notebook\markdown\image\AWSのクラウドデザイン一例.png)

### ◆ RegionとAvailability Zone

2016年1月6日時点では、以下のRegionにデータセンター群がある。各データセンターには、別系統の電源、空調、ネットワーク機器によって運用されているAvailability Zoneが設置されている。東京Regionには、3つのAvailability Zoneがある。

![AWSリージョンマップ](C:\Projects\tech-notebook\markdown\image\AWSリージョンマップ.PNG)



### ◆ Route 53

クラウドDNSサーバーとして働く。リクエストされた完全修飾ドメイン名とインスタンスのグローバルIPアドレスをマッピングしている。



### ◆ CloudFront

クラウドプロキシサーバとして働く。Bucketへのアクセスをキャッシングする。



### ◆ S3：Simple Storage Service

- **Bucket**

クラウドストレージとして働く。Amazon S3に保存するCSSファイルや画像ファイルを管理できる。



### ◆ VPC：Virtual Private Cloud

クラウドプライベートネットワークとして働く。プライベートIPアドレスが割り当てられた、VPCと呼ばれるプライベートネットワークを仮想的に構築することができる。異なるAvailability Zoneに渡って仮想サーバを立ち上げることによって、仮想サーバをデュアル化することできる。

![VPCが提供できるネットワークの範囲](C:\Projects\tech-notebook\markdown\image\VPCが提供できるネットワークの範囲.png)

- **AZ：Availability Zone**

VPCの中に、AZと呼ばれる物理的に離れたデータセンターがある。AZの中に、VPC subnetを作ることができ、そこにインスタンス（クラウドWebサーバ）を構築できる。

- **ELB：Elastic Load Balancing**

デュアル化させたインスタンスへのアクセスを自動的に分配し、サーバへの負荷を緩和するサービス。



### ◆ Dualシステム（再掲）

同じ処理を行う2つのシステムからなるシステム構成のこと。随時、処理結果を照合する。いずれかが故障した場合、異常が発生したシステムを切り離し、残る片方で処理を続けることによって、故障を乗り切る。

![デュアルシステム](C:\Projects\tech-notebook\markdown\image\デュアルシステム.png)



# 05-01. GCPによるWebサービスのリリース

GCPから、グローバルIPアドレスと完全修飾ドメイン名が提供され、Webサービスがリリースされる。

**【クラウドデザイン例】**

以下のデザイン例では、Dualシステムが採用されている。

![GCPのクラウドデザイン一例](C:\Projects\tech-notebook\markdown\image\GCPのクラウドデザイン一例.png)

### ◆ GAE：Google App Engine：GAE

クラウドデプロイサーバとして働く。AWSにおけるElastic Beanstalkに相当する。



### ◆ GCE：Google Compute Engine

クラウドWebサーバとして働く。AWSにおけるEC2に相当する。