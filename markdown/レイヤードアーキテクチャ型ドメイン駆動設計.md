# 01. MVCとは

ドメイン駆動設計が考案される以前、MVCの考え方が主流であった。

![MVCモデル](https://user-images.githubusercontent.com/42175286/57635646-8838e700-75e2-11e9-837d-253c006b7725.png)



### ◆ MVCからドメイン駆動設計への発展

しかし、特にModelの役割が抽象的過ぎたため、開発規模が大きくなるにつれて、Modelに役割を集中させ過ぎてしまうことがあった。それから、ドメイン駆動設計が登場したことによって、MVCは発展し、M・V・Cそれぞれの役割がより具体的で精密になった。



# 02. ドメイン駆動設計とは

### ◆ドメインエキスパートとユビキタス言語

ドメインエキスパート（現実世界の業務内容に詳しく、また実際にシステムを使う人）と、エンジニアが話し合いながら、設計していく。設計の時、ドメインエキスパートとエンジニアの話し合いに齟齬が生まれぬように、ユビキタス言語（業務内容について共通の用語）を設定しておく。



### ◆ 戦略的設計

1. ドメインエキスパートと話し合い、現実世界の業務内容に含まれる『名詞』と『振舞』に着目。
2. 『名詞』と『振舞』を要素として、EntityやValueObjectを設計。
3. 設計されたEntityやValueObjectを用いて、ドメインモデリング（オブジェクト間の関連付け）を行う。



### ◆ 戦術的設計

戦略的設計を基に、各オブジェクトとオブジェクト間の関連性を実装していく。

![DDDの概念](https://user-images.githubusercontent.com/42175286/61179612-d305c800-a640-11e9-8c4a-3d31225af633.jpg)



### ◆ ドメイン駆動設計の派生型

現在までに、ドメイン駆動設計の派生型がいくつか提唱されている。

- **Layered architecture**

- **Hexagonal architecture**

- **Onion architecture**

  

# 03. Layeredアーキテクチャ型ドメイン駆動設計

### ◆ 責務の分担方法

![ドメイン駆動設計](https://user-images.githubusercontent.com/42175286/58724663-2ec11c80-8418-11e9-96e9-bfc6848e9374.png)

Layeredアーキテクチャ型ドメイン駆動設計において、MVCは、以下の4層に再編成できる。

- **User Interface層**
- **Application層**
- **Domain層（ビジネロジックをコード化）**
- **Infrastructure層（データベースとマッピング）**



# 04. アーキテクチャにおける処理の流れの全体像

処理フローは、『([**Vuex**](https://github.com/Hiroki-IT/Symfony2_Nyumon/wiki/10.-(%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88)-%E2%9E%94-(Web%E3%83%9A%E3%83%BC%E3%82%B8))) ⇄ ([**AJAX**](https://github.com/Hiroki-IT/Symfony2_Nyumon/wiki/06.-(API)-%E2%9E%94-(Web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0))) ⇄ ([**DDD**](https://github.com/Hiroki-IT/Symfony2_Nyumon/wiki/02.%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88%E3%81%A8%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)) ⇄ (DB) 』で実装される。クリックで解説ページへジャンプ。

![Vuex と DDD-1](https://user-images.githubusercontent.com/42175286/58743936-d7519980-8475-11e9-83b2-0d10505206b9.png)

![Vuex と DDD-2](https://user-images.githubusercontent.com/42175286/58744171-a1aeaf80-8479-11e9-9844-f9beb6f13327.png)



# 05. API ⇆ サーバサイド

### ◆ APIの概念

![API](https://user-images.githubusercontent.com/42175286/58460636-04960300-8169-11e9-8fa0-18a307f3425b.png)

> In computer programming, an application programming interface (API) is a set of subroutine definitions, communication protocols, and tools for building software. In general terms, it is a set of clearly defined methods of communication among various components.

> コンピュータプログラミングでは、アプリケーションプログラミングインターフェイス（API）は、サブルーティン定義、通信プロトコル、ソフトウェアを構築するための一連の方法。 一般的に、様々なコンポーネント間で明確に定義された一連の通信方法のことを言う。

**【具体例】**

- **Ajaxに含まれるXMLHttpRequestとDOM**

```javascript

```

- **JSON API**

```javascript
    /**
     * @var \DateTime
     * 
     * #マッピングするテーブルを指定
     * @ORM\Column(name="date", type="datetime")
     *
     * #Expose()でJSON形式に変換することを宣言
     * @JSON\Expose()
     *
     * #JSONに出力するときのフォーマット
     * @JSON\Type("DateTime<'Y-m-d'>")
     */
    private $date;
```



### ◆ AJAXを用いたAPI

![AJAXと普通のサーバーの組み合わせ](https://user-images.githubusercontent.com/42175286/58530270-17681080-8219-11e9-9d34-0c457126b12b.png)

AJAX（Asynchronous JavaScript + XML）は、以下の４つから構成される。
- **JavaScript**：  
- **XML HttpRequest**
オブジェクト形式で書かれ、ブラウザとサーバー間を繋ぐAPI。
- **DOM**：
xmlやhtmlをツリー構造で表現することによって、ブラウザとサーバー間を繋ぐAPI。
- **XML**：  

![AJAXの処理フロー](https://user-images.githubusercontent.com/42175286/58467340-6741cb80-8176-11e9-9692-26e6401f1de9.png)

1. ページ上で任意のイベントが発生（ボタンクリックなど）
1. JavaScript + XMLHttpRequestでサーバーに対して、ルーティングを基にコントローラにリクエストを送信
1. サーバーで受け取った情報を処理。サーバーの処理中もクライアントは操作を継続可能（これぞ非同期通信）。
1. コントローラは処理結果をJSONやXMLなどの形式でレスポンスを送信。
1. レスポンスを受けて、DOMでページを更新。

**【実装例】**

```javascript
  static find(criteria, b, c) {
    
    //jQueryのAJAXメソッド発動
    return $.ajax({
      type:        'GET', #HTTPリクエストとしてGETメソッドを指定
      url:         '/xxx/xxx-url', #コントローラを指定
      contentType: 'application/json',
      dataType:    'json', #リクエストにJSON形式を指定
      data: (() => {
        const query = {
          criteria: criteria,
          b: b,
          c: c,
        };

        // 検索条件を設定
        if (criteria.id) {
          query.id = criteria.id;
        }

        return query;
      })(),
    })
      .then((data) => {
        return {
　　　　　　dataの配列
        };
      });
  }
```



### ◆ Object ⇄ JSON の変換

![serialization vs deserialization](https://user-images.githubusercontent.com/42175286/58675481-79e31d00-838f-11e9-972d-d4a5d5ed6a55.png)

**【実装例】**

```javascript
#【Object】
{foo: [1, 4, 7, 10], bar: "baz"}
```

⇓ ⇑

```javascript
#【JSON】
'{"foo":[1,4,7,10],"bar":"baz"}'
```



# 06. カーネル

![図2-9-ver2](https://user-images.githubusercontent.com/42175286/57711074-08c21b00-76a9-11e9-959e-b3777f70d2c6.png)


### ◆ カーネルに必要なオブジェクト
1. Requestオブジェクト：グローバル変数から収集した情報やHTTPリクエストのヘッダ情報やコンテンツ情報を保持
1. カーネルオブジェクトの```handle()```：送られてきたURLを基にしたコントローラ／アクションへのルートの特定、特定されたコントローラ／アクションの実行、テンプレートのレンダリング
1. Responseオブジェクト：HTTPレスポンスのヘッダ情報やコンテンツ情報などの情報を保持



### ◆ オブジェクトから取り出されたメソッドの役割

1. カーネルが、クラアントからのHTTPリクエストをリクエストオブジェクトとして受け取る。
1. カーネルが、送られてきたURLとルート定義を基に、リクエストに対応するコントローラアクションを探し、実行させる。その後、テンプレートがURLを生成。
1. カーネルが、その結果をレスポンスオブジェクトとしてクライアントに返す。
このカーネルを、特別に『HTTPカーネル』と呼ぶ。

**【app.phpの実装例】**

```PHP
$kernel = new AppKernel('dev', true); 
if (PHP_VERSION_ID < 70000) {
    $kernel->loadClassCache();
}
$request = Request::createFromGlobals();  //（１）
$response = $kernel->handle($request); //（２）
$response->send(); //（３）
$kernel->terminate($request, $response);
```

**【Kernel.phpの実装例】**
handle()が定義されているファイル。ここで定義されたhandle()が、C/Aへのルートの特定、特定されたC/Aの実行、テンプレートのレンダリングを行う。

```PHP
/** 
* {@inheritdoc}
*/
public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
{
　$this->boot();
　++$this->requestStackSize;
　$this->resetServices = true;

　try {
　return $this->getHttpKernel()->handle($request, $type, $catch);
　} finally {
　--$this->requestStackSize;
　}
}
```



# 07. Dependency Inversion Principle（依存性逆転の原則）

### ◆ DIPとは

1. 上位のモジュールは、下位のモジュールに依存してはならない。どちらのモジュールも『抽象』に依存すべきである。
2. 『抽象』は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである。



### ◆ DIPに基づくドメイン駆動設計

Repositoryの抽象クラスは、ドメイン層に配置する。そして、Repositoryの実装クラスはInfrastructure層に配置する。抽象クラスで抽象メソッドを記述することによって、実装クラスでの実装が強制される。つまり、実装クラスは抽象クラスに依存している。依存性逆転の原則に基づくことによって、ドメイン層への影響なく、Repositoryの交換が可能。

![ドメイン駆動設計_逆転依存性の原則](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_依存性逆転の原則.jpg)



# 08. Entity

### ◆ Entityとは

オブジェクトをEntityとしてモデリング／実装したいのならば、以下に条件を満たす必要がある。

（ユビキタス言語の例）顧客、注文など

1. 状態を変化させる必要があるプロパティをもつ。
2. オブジェクトにアイデンティティがあり、他のオブジェクトと同じ属性をもっていても、区別される。 

![ドメイン駆動設計_エンティティ](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_エンティティ.jpg)

**【実装例】**

```PHP
class DogToyEntity
{
	// おもちゃ種別VO
	private $toyType;
	
	// おもちゃ商品名
	private $toyName;
	
	// 数量
	private $number;
	
	// 価格VO
	private $priceVO;
	
	// 色VO
	private $colorVO;
	
	
	// Setterを実装
	public function __construct
	(
		ToyType $toyType,
		String $toyName,
		Int $number,
		priceVO $priceVO,
		ColorVO $colorVO
	)
	{
		$this->toyType = $toyType,
		$this->toyName = $toyName,
		$this->number = $number,
		$this->priceVO = $priceVO,
		$this->colorVO = $colorVO
	}
	
	
	// 自身と下位VOを用いて、集約を構成
	public static function aggregateDogToyEntity(Array $fetchedData)
	{
		return new DogToyEntity
		(
			new ColorVO($fetchedData['dog_toy_type']),
			$fetchedData['dog_toy_name'],
			$fetchedData['number'],
			new PriceVO($fetchedData['dog_toy_price']),
			new ColorVO($fetchedData['color_value'])
		);
	}	

	
	// Getterを実装
	public function toyNameWithColor()
	{
		if($this->toyName && $this->colorVO->colorName());
		return sprintf;
		(
            '%s（%s）',
            $this->toyName,
            $this->colorVO->colorName()
		)
	}
	
}
```



### ◆ RouteEntityとは

  EntityやValueObjectからなる集約の中で、最終的にアプリケーション層へレスポンスされる集約を、『RouteEntity』という。

![ドメイン駆動設計_集約関係](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_集約関係.jpg)

**【実装例】**

```PHP
class ToyOrderEntity
{
	// 犬用おもちゃ
	private $dogToyEntity;
	
	// 猫用おもちゃ
	private $catToyEntity;
	
	// Setterを実装
	public function __construct
	(
		DogToyEntity $dogToyEntity,
		CatToyEntity $catToyEntity
	)
	{
		$this->dogToyEntity = $dogToyEntity;
		$this->catToyEntity = $catToyEntity;
	}
	
	// 自身と下位Entityを用いて、『RouteEntity』の集約を構成
	public static function aggregateToyOrderEntity
	(
        Array $fetchedData
	): ToyOrderEntity
	{
		return new toyOrderEntity
		(
			DogToyEntity::aggregateDogToyEntity($fetchedData),
			CatToyEntity::aggregateCatToyEntity($fetchedData)
		);
	} 
	
}	
```



# 09. ValueObject

オブジェクトをValueObjectとしてモデリング／実装したいのならば、以下に条件を満たす必要がある。

![ドメイン駆動設計_バリューオブジェクト](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_バリューオブジェクト.jpg)

**【実装例】**

```PHP
/**
 * 支払情報オブジェクト
 */
class PaymentInfoVO
{
    // 予め実装したImmutableObjectトレイトを用いて、プロパティの不変性を実現
    use ImmutableObject;

    /**
     * 支払いID
     *
     * @var PaymentId
     */
    private $PaymentId;

    /**
     * 支払い方法
     *
     * @var PaymentType
     */
    private $PaymentType;
    
    /**
     * 連絡先メールアドレス
     *
     * @var string|null
     */
    private $contactMail;
    
    /**
     * 金額
     *
     * @var Money
     */
    private $price;    

```

### ◆ （1）ドメイン層の計測、定量化、説明

金額、数字、電話番号、文字列、日付、氏名、色など、一意に識別する必要がないユビキタス言語をオブジェクトモデルで表現する時に、ValueObjectとしてモデリング／実装すべき。例えば、電話番号を表すために、Int型ではなく、PhoneNumber型で定義する。



### ◆ （2）プロパティの不変性

インスタンス化時に自動的に呼び出される```__construct()```を用いる。インスタンス化時に実行したい処理を記述できる。Setterを持たせずに、```__construct()```でのみ値の設定を行えば、ValueObjectのような、『Immutable』なオブジェクトを実現できる。

**【実装例】**

```PHP
class Test02 {

    private $property02;

	// コンストラクタで$property02に値を設定
    public function __construct
    (
    	$property02
    )
    {
        $this->property02 = $property02;
    }
    
}
```

- **『Immutable』を実現できる理由**

Test01クラスインスタンスの```$property01```に値を設定するためには、インスタンスからSetterを呼び出す。Setterは何度でも呼び出せ、その度にプロパティの値を上書きできてしまう。

```PHP
$test01 = new Test01;

$test01->setProperty01("プロパティ01の値");

$test01->setProperty01("新しいプロパティ01の値");
```

一方で、Test02クラスインスタンスの```$property02```に値を設定するためには、インスタンスを作り直さなければならない。つまり、以前に作ったインスタンスの```$property02```の値は上書きできない。Setterを持たせずに、```__construct()```だけを持たせれば、『Immutable』なオブジェクトとなる。

```PHP
$test02 = new Test02("プロパティ02の値");

$test02 = new Test02("新しいプロパティ02の値");
```



### ◆ （3）概念的な統一体

```

```





### ◆ （4）オブジェクトの交換可能性

オブジェクトが新しくインスタンス化された場合、以前に同一オブジェクトから生成されたインスタンスから新しく置き換える必要がある。



### ◆ （5）オブジェクト間の等価性

全てのプロパティの値が他のVOと同じ場合、同一のVOと見なされる。

 

### ◆ （6）メソッドによってオブジェクトの状態が変わらない

**【実装例1】**

```PHP
// （1）ドメイン層の氏名を扱うVO
class NameVO
{
   // （2）予め実装したImmutableObjectトレイトを用いて、プロパティの不変性を実現
    use ImmutableObject;

    // 苗字プロパティ
    private $lastName;
    
    // 名前プロパティ
    private $firstName;
    
    // （6） メソッドによってオブジェクトの状態が変わらない
    public function fullName(): String
    {
    	return $this->lastName . $this->firstName;
    }
    
    // 
    protected static function computedPropertyNames()
    {
        return [
            'fullName'
        ];
    }
}
```

**【実装例2】**

同様に、Immutableトレイトを基に、VOを生成する。

```PHP
// ドメイン層の金額を扱うVO
class Money
{

}
```



### ◆ EntityとValueObjectのどちらとして、モデリング／実装すべきなのか？

EntityとValueObjectのどちらとして、オブジェクトモデルをモデリング／実装すべきなのかについて考える。そもそも、大前提として、『オブジェクトモデルはできるだけ不変にすべき』というベストプラクティスがあり、その結果、ValueObjectというが生まれたと考えられる。実は、ValueObjectを使わずに全てEntityとしてモデリング／実装することは可能である。しかし、不変にしてもよいところも可変になり、可読性や信頼性を下げてしまう可能性がある。



# 10. TypeCode（標準型）

### ◆ TypeCode（標準型）とは

一意に識別する必要がないユビキタス言語の中でも、特に『区分』や『種類』などは、ValueObjectとしてではなく、TypeCodeとしてモデリング／実装する。VOまたはEnumによって実装する。



### ◆ EnumによるTypeCodeの実装

**【実装例1】**

```PHP
class ColorVO extends Enum
{
	const RED = '1';
	const BLUE = '2';

	// 『self::定数名』で、定義の値へアクセスする。
	private $defs = [
		self::RED => ['colorname' => 'レッド'];
		self::BLUE => ['colorname' => 'ブルー'];
	];

	// 色値プロパティ
	private $colorValue;
	
	// 色名プロパティ。
	private $colorName;
	
	
	// インスタンス化の時に、『色の区分値』を受け取る。
	public function __construct
	(
        String $value
	)
	{
		// $kbnValueに応じて、色名をcolornameプロパティにセットする。
		$this->colorValue = $value;
		$this->colorname = $this->defs[$value]['colorName'];
	}
    
    
    // constructによってセットされた色値を返すメソッド。
	public function colorValue() :Int
	{
		return $this->colorValue;
	} 


	// constructによってセットされた色名を返すメソッド。
	public function colorName() :String
	{
		return $this->colorName;
	} 
	
}
```



# 11. Id

- **実装例**





# 12. Service

他の３区分に分類できないもの（例：Id-Aを生成するId-B）。



# 13. Repository

### ◆ Repositoryとは

構成したい集約とRepositoryは、一対一の関係になる。例えば、OrderのRouteEntityからなる集約を構成するRepositoryは、OrderRepositoryと名付ける。



### ◆ 抽象クラス

DIPに基づくドメイン駆動設計の場合、Repositoryの抽象クラスを配置する。

![ドメイン駆動設計_逆転依存性の原則](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_依存性逆転の原則.jpg)



### ◆ 集約構成とデータ挿入

1. アプリケーション層から集約がリクエストされる。
2. ファクトリの呼び出しによって、EntityやValueObjectから構成される集約を新しく構成
3. データベースに追加する。
4. ![ドメイン駆動設計_リポジトリ_データ更新](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_リポジトリ_データ更新.png)

**【実装例】**

```PHP
// 集約を新しく構成するRepository
class ToyOrderRepository
{
	// データベースへの挿入の前処理として、カラム名を値に持つ連想配列で定義
	$data = [
		'type' => XXX 
		'name' => XXX
		'number' => XXX
		'price' => ($order->priceVO) ? $order->priceVO->amount() : 0,
		'color_value' => ($order->colorVO) ? $order->colorVO->value() : null
	];
	
	return $data;
}
```



### ◆ データ取得と集約再構成

1. データベースからデータを取得。
2. ファクトリの呼び出しによって、EntityやValueObjectから構成される集約を加工し、再構成する。
3. 再構成された集約をアプリケーション層にレスポンス。

![ドメイン駆動設計_リポジトリ_データ取得](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ドメイン駆動設計_リポジトリ_データ取得.jpg)

**【実装例】**

```PHP
// データ取得と集約再構成を行うRepository
class ToyOrderRepository
{

	// データベースからデータを取得
	public function fetchDataSet()
	{
		$select = [
			'dog_toy.type AS dog_toy_type',
			'dog_toy.name AS dog_toy_name',
			'dog_toy.number AS number',
			'dog_toy.price AS dog_toy_price',
			'color.color_value AS color_value'
		];
        
		$query = $this->getFecthQuery($select);
		return $query->getConnection()->executeQuery()->fetchAll(); 
	}
	
	
	// 『RouteEntity』の配列をアプリケーション層へレスポンス
	public function arrayedToyOrderEntities(): ToyOrderEntities
	{	
		$toyOrderEntities = [];
		foreach($this->fetchDataSet() as $fetchedData){
			$toyOrderEntities[] = ToyOrderEntity::aggregateToyOrderEntity($fetchedData)
		}
        
		return $toyOrderEntities;
	}
	
}
```



# 14. Factory

### ◆ Factoryとは

責務として、構成した集約関係を加工して新sたな集約を再構成する。

- **実装例**

```PHP
class Factory
{
	private $factory

	public function __construct
	(
        Factory $factory
	)
	{
		$this->$factory = $factory
	}
	
	public function ToyInstance()
	{
		isset($this->factory){
			//なんらかの集約処理;
		}
	}
}
```



# 15. Controller

責務として、ドメイン層の抽象メソッドを用いて、Use case（使用事例）を実装する。

**【具体例】**

オンラインショッピングにおけるUse case

![ユースケース図](https://raw.githubusercontent.com/Hiroki-IT/tech-notebook/master/markdown/image/ユースケース図.png)






