# 1. MVCとは

ドメイン駆動設計が考案される以前、MVCの考え方が主流であった。

![MVCモデル](https://user-images.githubusercontent.com/42175286/57635646-8838e700-75e2-11e9-837d-253c006b7725.png)



### ◇ MVCからドメイン駆動設計への発展

しかし、特にModelの役割が抽象的過ぎたため、開発規模が大きくなるにつれて、Modelに役割を集中させ過ぎてしまうことがあった。それから、ドメイン駆動設計が登場したことによって、MVCは発展し、M・V・Cそれぞれの役割がより具体的で精密になった。



# 2. ドメイン駆動設計とは

ドメインエキスパート（現実世界の業務内容に詳しく、また実際にシステムを使う人）と、エンジニアが話し合いながら、設計していく。設計の時、ドメインエキスパートとエンジニアの話し合いに齟齬が生まれぬように、ユビキタス言語（業務内容について共通の用語）を設定しておく。

（例）会計業務用アプリ



### ◇ 戦略的設計

現実世界の業務内容に対してオブジェクトモデリングを行い、それらオブジェクトを基にドメインモデリング（オブジェクト間の関連付け）を行う。



### ◇ 戦術的設計

戦略的設計を基に、各オブジェクトとオブジェクト間の関連性を実装していく。

![DDDの概念](https://user-images.githubusercontent.com/42175286/61179612-d305c800-a640-11e9-8c4a-3d31225af633.jpg)



### ◇ ドメイン駆動設計の派生型

現在までに、ドメイン駆動設計の派生型がいくつか提唱されている。

- **Layered architecture**

- **Hexagonal architecture**

- **Onion architecture**

- **Clean architecture**



# 3. Layered architecture 型ドメイン駆動設計

### ◇ 責務の分担方法

![ドメイン駆動設計](https://user-images.githubusercontent.com/42175286/58724663-2ec11c80-8418-11e9-96e9-bfc6848e9374.png)

レイヤードアーキテクチャ型ドメイン駆動設計において、MVCは、以下の4層に再編成できる。

- **User Interface層**
- **Application層**
- **Domain層（ビジネロジックをコード化）**
- **Infrastructure層（データベースとマッピング）**



### ◇ DIP：Dependency Inversion Principle（依存性逆転の原則）

- **DIPとは**

1. 上位のモジュールは、下位のモジュールに依存してはならない。どちらのモジュールも『抽象』に依存すべきである。
2. 『抽象』は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである。

- **DIPに基づくドメイン駆動設計**

Repositoryの抽象クラスは、ドメイン層に配置する。そして、Repositoryの実装クラスはInfrastructure層に配置する。抽象クラスで抽象メソッドを記述することによって、実装クラスでの実装が強制される。つまり、実装クラスは抽象クラスに依存している。依存性逆転の原則に基づくことによって、ドメイン層への影響なく、Repositoryの交換が可能。

![ドメイン駆動設計_逆転依存性の原則](C:\Projects\Summary_Notes\まとめノート\画像\ドメイン駆動設計_逆転依存性の原則.jpg)



# 4. Domain層

### ◇ Entity

![ドメイン駆動設計_エンティティ](C:\Projects\Summary_Notes\まとめノート\画像\ドメイン駆動設計_エンティティ.jpg)

（ユビキタス言語の例）顧客、注文など

1. ビジネスロジックにおけるオブジェクトを考える。

1. その中で、以下のオブジェクトをEntityとする。

  （1）変化させる必要があるプロパティをもつ。

  （2）他のオブジェクトと同じ属性をもっていても、区別する必要がある。 

- **Entity の実装**

```
#（実装例）
class Entity
{
	# ValueObjectプロパティ。
	private $kbnValue;
	
	public function aggregatedEntity(){
		
		# 
		$kbnValue = new ValueObject($dataset[kbn_value]);
	
		# セットしたValueObjectをEntityに集約させる。
		return new Entity(
			$kbnValue
	);
}

```



### ◇ Id

- **実装例**



### ◇ Value Object

![ドメイン駆動設計_バリューオブジェクト](C:\Projects\Summary_Notes\まとめノート\画像\ドメイン駆動設計_バリューオブジェクト.jpg)

（ユビキタス言語の例）数字、文字列、日付、氏名、金額、色など

1. ビジネスロジックにおけるオブジェクトを考える。

1. その中で、以下のオブジェクトを、Value Objectとする。

  （1）変化させる必要がないプロパティをもつ。

  （2）他のオブジェクトと同じ属性をもっていたら、同一のオブジェクトと見なす必要がある。 

- **Value Object の実装例**

```
# 列挙型によって、Value Objectを実装
class ValueObject extends Enum
{


	const 定数X = 1
	const 定数Y = 2


	# 『self::定数名』で、定義の値へアクセスする。
	private $defs = [
		self::定数X => 区分名X;
		self::定数Y => 区分名Y;
	];


	# 区分名プロパティ。
	private $name;


	# インスタンス化の時に$kbnValueを受け取る。
	public function __construct(string $kbnValue){
	
		public function kbnValue($kbnValue){
			return $kbnValue
		}
	
		# $kbnValueに応じて、区分名をnameプロパティにセットする。
		$this->name = $this->defs[$kbnValue]	
	}	
		

	# インスタンス化の時にセットされた区分名を返すメソッド。
	public function name()
	{
		return $this->name;
	} 


	# $kbnValueが"1"だった場合にTrueを返すメソッド。
	public function constantX(){
	
		# constructメソッドへアクセス
		return $this->kbnValue() === self::定数X;
	} 


   # $kbnValueが"2"だった場合にTrueを返すメソッド。
	public function constantY(){
	
		# constructメソッドへアクセス
		return $this->kbnValue() === self::定数Y;
	} 
}
```



### ◇ Service

他の３区分に分類できないもの（例：Id-Aを生成するId-B）。



### ◇ Repository の抽象クラス（※DIPに基づく場合）

DIPに基づくドメイン駆動設計の場合、Repositoryの抽象クラスを配置する。





# 5. Infrastructure層

### ◇ 『Entity』と『Value Object』の集約

![ドメイン駆動設計_集約関係](C:\Projects\Summary_Notes\まとめノート\画像\ドメイン駆動設計_集約関係.jpg)



### ◇ Factory

複雑な集約を構成する場合、集約を再構成するFactoryを別途用意する。

- **実装例**

```
class Factory
{
	#
	private $factory


	#
	public function __construct(Factory $factory){
		$this->$factory = $factory
	}
	
	
	# 
	public function restructureFactory(){
		isset($this->factory){
			//なんらかの集約処理;
		}
	}
}
```



### ◇ Repository の実装クラス

![ドメイン駆動設計_リポジトリ（DBから取得）](C:\Projects\Summary_Notes\まとめノート\画像\ドメイン駆動設計_リポジトリ（DBから取得）.jpg)

- **実装例**


```
class Repository
{
	# 集約。
	public function repository(){
		aggregation($this->fetch())
	}


	# 
	public function fetch(){
		$select = [
			'table.kbn_value AS kbn_value'
		];
	
    	$query = $this->getFecthQuery($select);
    	
		$dataSet = $query->getConnection()->executeQuery()->fetchAll();
        
        return Traversable::from($dataSet)->select({
        	function ($data)
        	$dataSet = [
        		'kbn_value' => 
        	];
        	return $dataSet;	
        })->asArray();
	}
	

	#
	public function aggregation($dataSet)
	{
		$entity = new Entity
	
		# Entityオブジェクト に Value Object を集約させる
		$entity->kbnValue = new ValueObject($dataSet['kbn_value'])
	);
}
```



# 6. Application層

### ◇ Controller

ドメイン層の抽象メソッドを用いて、Use case（使用事例）を実装する。

（例）オンラインショッピングにおけるUse case

![ユースケース図](D:\Documents\Drive 1st\プログラミング自習\まとめノート\随時、リポジトリの画像フォルダへコピーせよ\ユースケース図.png)