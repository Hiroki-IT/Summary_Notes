# 勉強の方針

1. 必ず、実例として、それが扱われているのかを覚えること。
2. 必ず、言葉ではなく、イラストを用いて覚えること。
3. 必ず、知識の『点』と『点』を繋ぎ、『線』にしろ
4. 必ず、まとめることでインプットしているだけなので、口頭で説明してアプトプットしろ。
5. キタミ式で大枠をとらえて、過去問で肉付けしていく。



# 11-01. データベースとは

### ◇ データベース管理システム（DBMS）

![DBMS](C:\Projects\Summary_Notes\まとめノート\画像\DBMS.jpg)

### ◇ Transaction

![p328](C:\Projects\Summary_Notes\まとめノート\画像\p328.gif)



### ◇ Stored Procedure

あらかじめ一連のSQL文をデータベースに格納しておき、Call文で呼び出す方式。

![p325](C:\Projects\Summary_Notes\まとめノート\画像\p325.gif)

**【実装例】**

```
# PROCEDUREを作成
CREATE PROCEDURE SelectContact AS　
  SELECT CustomerID, CompanyName, ContactName, Phone
  FROM Customers
```

```
# PROCEDUREを実行
EXEC SelectContact
```



### ◇ ACID特性

トランザクション処理では、以下の４つの性質が保証されている必要がある。

- **Atomicity**

  コミットメント制御によって実装される。

- **Consistency** 

  排他制御によって実装される。

- **Isolation** 

  排他制御によって実装される。

- **Durability** 

  障害回復制御によって実装される。



### ◇ コミットメント制御

**【実装例】**トランザクション、コミットメント制御、ロールバック機能

```
try{
    // データベースと接続。
    $db = getDb();

    // 例外処理を有効化。
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // トランザクションを開始。
    $db->beginTransaction();
    // いくつかのSQLが実行される。※もし失敗した場合、ERRMODE_EXCEPTIONを実行。
    $db->exec("INSERT INTO movie(title, price) VALUES('ハリポタ', 2000)")
    $db->exec("INSERT INTO movie(title, price) VALUES('シスター', 2000)")
   
    // トランザクションの全てのSQLに成功したら、トランザクションをコミット。
    $db->commit();
}
catch{
	// 例外が発生したらロールバックし、エラーメッセージを出力。
	$db->rollBack();
	print "エラーメッセージ：{$e->getMessage()}"
}    
```

- **Transaction**

  SQLによる一連のCRUDを一繋ぎにした処理のこと。
  
  **【例】**銀行ATMの振込処理によるCRUD
  
- **コミット機能**

  トランザクションとしてくくられた処理が全て実行された時、その処理結果を確定させ、データを更新する機能。

![コミットメント制御-1](C:\Projects\Summary_Notes\まとめノート\画像\コミットメント制御-1.gif)

- **ロールバック機能**

  トランザクションを中断する何らかの事象が発生した時などに、処理を取り消し、トランザクション開始以前の状態に戻す機能

![コミットメント制御-2](C:\Projects\Summary_Notes\まとめノート\画像\コミットメント制御-2.gif)

- **二相コミット**

  コミットを以下の二つの段階に分けて行うこと。ACIDのうち、原子性と一貫性を実装している。

  （１）他のサイトに更新可能かどうかを確認。

  （２）全サイトからの合意が得られた場合に更新を確定。



### ◇ 排他制御

- **なぜ排他制御が必要か**

  ![排他制御-1](C:\Projects\Summary_Notes\まとめノート\画像\排他制御-1.png)

- **排他制御を行った結果**

  ![排他制御-2](C:\Projects\Summary_Notes\まとめノート\画像\排他制御-2.png)

- **排他制御の種類**

  CRUDのRead以外を実行不可能にする共有ロックと、CRUDの全てを実行不可能にする占有ロックがある。「共有」の名の通り、共有ロックされているデータに対して、他の人も共有ロックを行うことができる。

**【実装例】**

```
// ファイルを共有ロック
flock($file, LOCK_SH);

// ロックの解除
flock($file, LOCK_UN);
```

![排他制御-3](C:\Projects\Summary_Notes\まとめノート\画像\排他制御-3.gif)

- ロックの粒度**

  ![ロックの粒度](C:\Projects\Summary_Notes\まとめノート\画像\ロックの粒度-1.png)

  DB ＞ テーブル ＞ レコード ＞ カラム の順に、粒度は大きい。ロックの粒度が細かければ、トランザクションの同時実行性が高くなって効率は向上する（複数の人がDBに対して作業できる）。しかし、ロックの粒度を細かくすればするほど、それだけデータベース管理システムのCPU負荷は大きくなる。

  ![ロックの粒度-2](C:\Projects\Summary_Notes\まとめノート\画像\ロックの粒度-2.jpg)

- **デッドロック現象**

  もう一方のレコードのロックが解除されないと、自身のレコードのロックを解除できない時、処理が停止するデッドロック現象が起こる。

  ![デッドロック](C:\Projects\Summary_Notes\まとめノート\画像\デッドロック.gif)



### ◇ 障害回復制御

![DBの関連性](C:\Projects\Summary_Notes\まとめノート\画像\DBの関連性.gif)

- **ログファイル（ジャーナルファイル）**

  データベースの処理履歴を記録したファイル。更新前ログファイルや更新後ログファイルとして残しておく。

- **チェックポイント**

  システムで障害が発生した場合、チェックポイントを設け、ログファイルの作成やデータベースのバックアップを行う。

- **Roll forward**

  ハードディスクの不具合でデータベースが破損した場合、まず、チェックポイントまでデータベースを復元する。次に、更新後ログファイルを読み込んでディスク破損直前の状態まで復元する。 

- **Roll back**

  更新処理中に異常が発生した場合、まず、チェックポイントまでデータベースを復元する。次に、更新前ログファイルを読み込んで障害前の状態まで戻し、更新処理自体を無かったことにする。

  

# 11-02. データベースの設計方法

### ◇ **UMLによる設計**

16章を参照。Squidの設計図では、UMLとER図を組み合わせている。



### ◇ **ER図による設計：Entity Relation Diagram**

16章を参照。Squidの設計図では、UMLとER図を組み合わせている。



# 11-03. テーブルの設計と作成

### ◇ 主キー

テーブルの中で、Rowデータを一意に特定できる値を『主キー』の値と呼ぶ。

![主キー](C:\Projects\Summary_Notes\まとめノート\画像\主キー.jpg)



### ◇ データを追加するあるいは削除する場合の注意点

データを追加するあるいは削除する場合、カラムではなく、レコードの増減を行う。カラムの増減の処理には時間がかかる。一方で、レコードの増減の処理には時間がかからない。

![カラムの増減は✖、レコードの増減は〇](C:\Projects\Summary_Notes\まとめノート\画像\カラムの増減は✖、レコードの増減は〇-1.png)

**【具体例】**

賞与を年1回から、2回・3回と変える場合、主キーを繰り返し、新しく賞与区分と金額区分を作る。

![カラムの増減は✖、レコードの増減は〇-2](C:\Projects\Summary_Notes\まとめノート\画像\カラムの増減は✖、レコードの増減は〇-2.png)



### ◇ 非正規形の正規化（最適なカラム設計）

**『正規化』と『非正規形』**：繰り返し要素のある表を正規形、その逆を非正規形という。

**『正規化』**：非正規形の表から、他と連動するカラムを独立させ、正規形の表に変更すること。

**【具体例】**

1. エクセル

   エクセルで作られた以下の表があると仮定。

![非正規形](C:\Projects\Summary_Notes\まとめノート\画像\非正規形.png)

2. 第一正規化：**繰り返し要素の排除**

   レコードを1つずつに分割。

   ![第一正規形](C:\Projects\Summary_Notes\まとめノート\画像\第一正規形.png)

3. 第二正規化：**主キーの関数従属性を排除**

   特定のカラムが連動している（関数従属性）場合、カラムを左表として独立させる

   ![第二正規形-1](C:\Projects\Summary_Notes\まとめノート\画像\第二正規形-1.png)

   上で分割して生じた右表のカラムに関数従属性があるので、従属性のあるカラムを左表として独立させる。

   ![第二正規形-2](C:\Projects\Summary_Notes\まとめノート\画像\第二正規形-2.png)

   ![第二正規形-3](C:\Projects\Summary_Notes\まとめノート\画像\第二正規形-3.png)

4. 第三正規化：**主キー以外のカラムの関数従属性を排除**

   上で分割して生じた左表のカラムに関数従属性があるので、従属性のあるカラムを左表として独立させる。

![第三正規形](C:\Projects\Summary_Notes\まとめノート\画像\第三正規形-1.png)

![第三正規形-2](C:\Projects\Summary_Notes\まとめノート\画像\第三正規形-2.png)



### ◇ Migrationとinsert

1. 誰かが以下のMigrationファイルをmasterにPush
2. Migrationファイルをローカル環境にPull
3. ```db:reset```で、ローカル環境のDBスキーマとデータを更新

```
namespace Migration

class ItemQuery
{
	public static function insert()
	{
		return "INSERT INTO item_table VALUES(1, '商品A', 'レッド', 1000, 			'2019-07-24 07:07:07');"
	}
}
```



# 11-04. テーブルからのデータ取得

### ◇ select

- **in**

【IN句を使用しなかった場合】

```
SELECT * FROM fruit WHERE name = "みかん" OR name = "りんご";
```

【IN句を使用した場合】

```
SELECT * FROM fruit WHERE name IN("みかん","りんご");
```



### ◇ fetch

DBで取得したデータをプログラムに一度に全て送信してしまうと、プログラム側のメモリを圧迫してしまう。そこで、fetchで少しずつ取得する。

**【実装例】**

```getConnection()```を起点として、返り値から繰り返しメソッドを取得し、```fetchAll()```で、テーブルのクエリ名をキーとした連想配列が返される。

```
getConnection()->executeQuery($query, $params, $types, $qcp)->fetchAll()

/// 結果
Array　= (
　　[kbn_name] => レッド 
　　[kbn_value] => 2
　　[quantity] => 50
)
```



# 12-01. ネットワークの全体像

### ◇ インターネット、WAN、LAN

ネットワークには、『インターネット』『WAN』『LAN』がある。家庭内LAN、学内LAN、企業内LAN、企業WANなど、さまざまなネットワークがあり、インターネットは、それぞれのネットワークを互いに接続しているネットワークである。

![インターネットとWANとLAN](C:\Projects\Summary_Notes\まとめノート\画像\インターネットとWANとLAN.png)



### ◇ WAN、LANの具体例

例えば、LANとしてEthernet、WANとしてデジタル専用線を用いる。

![WAN、LANの具体例](C:\Projects\Summary_Notes\まとめノート\画像\WAN、LANの具体例.png)



### ◇ WANの種類と歴史

![WANの歴史](C:\Projects\Summary_Notes\まとめノート\画像\WANの種類と歴史.png)



### ◇ インターネット、WAN、LANのセグメント分類 

- **非武装地帯に設置するサーバの種類**

外部からのアクセスを受け付ける、DNSサーバ、Webサーバ、メールサーバ、Proxyサーバは、内部ネットワークではなく、非武装地帯に設置するべきである。その理由として、内部ネットワークに置いた場合、攻撃の影響が内部ネットワークに広がる可能性があるからである。一方で、データベースサーバへのアクセスは全てWebサーバを介して行われるため、内部セグメントに設置する。

![内部、DMZ、外部](C:\Projects\Summary_Notes\まとめノート\画像\内部、DMZ、外部.png)



### ◇ 外部Webサーバとのデータ通信に要する時間

ネットワークのデータ通信には光回線が用いられている。光は、30万km／秒であり、一周4万kmの地球を7.5周／秒できることからもわかるように、遠く離れた国にあるWebサーバであっても、データ通信に要する時間は、１秒にも満たない。



### ◇ サーバの処理能力向上の方法

- **スケールアップ ⇔ スケールダウン**

  サーバ自体のスペックをより高くすることで、サーバ当たりの処理能力を向上させる。その逆は、スケールダウン。

  ![スケールアップ](C:\Projects\Summary_Notes\まとめノート\画像\スケールアップ.png)

- **スケールアウト ⇔ スケールイン**

  サーバの台数を増やすことで、サーバ全体の処理能力を向上させる。その逆は、スケールイン。

  ![スケールアウト](C:\Projects\Summary_Notes\まとめノート\画像\スケールアウト.png)

  

### ◇ ネットワークにおけるデータ通信方法の種類

- **回線交換方式**

  少数対少数でデータ通信を行うため、送信時に、送信者と受信者の宛先情報は必要ない。

  ![回線交換方式](C:\Projects\Summary_Notes\まとめノート\画像\回線交換方式.png)

- **パケット交換方式**

  通信するデータをパケット化する。多数対多数でデータ通信を行うため、送信時に、送信者と受信者の宛先情報が必要になる。

  ![パケット交換方式](C:\Projects\Summary_Notes\まとめノート\画像\パケット交換方式.png)



# 12-02. 不正アクセスを防ぐ仕組み

### ◇ 不正アクセス防衛方法の種類

![ファイアウォール_ips_ids_waf](C:\Projects\Summary_Notes\まとめノート\画像\ファイアウォール_ips_ids_waf.png)


### ◇ ファイアウォール

- **パケットフィルタリング型ファイアウォール**

Webサーバ／Proxyサーバとのデータ通信において、パケットがインターネット層やトランスポート層を通過する時に機能するファイアウォール。IPアドレスやポート番号などのヘッダ情報によって、送られてきたパケットを許可するべきか、あるいは拒否するべきかの判断を行うファイアーウォール。

![パケットフィルタリング](C:\Projects\Summary_Notes\まとめノート\画像\パケットフィルタリング.gif)

**【具体例】**Win10における設定画面

![パケットフィルタリングの設定](C:\Projects\Summary_Notes\まとめノート\画像\パケットフィルタリングの設定.gif)

- **アプリケーションゲートウェイ型ファイアウォール（Proxy型）**

Webサーバ／Proxyサーバとのデータ通信において、パケットがアプリケーション層を通過する時に機能するファイアウォール。内部Proxyサーバ（プライベートネットワークとパブリックネットワーク間でデータ通信を代理するサーバー）を、ファイアウォールとして用いる。

![フォワードプロキシサーバーとリバースプロキシサーバ](C:\Projects\Summary_Notes\まとめノート\画像\フォワードプロキシサーバーとリバースプロキシサーバ.png)



### ◇ IPS：Intrusion Detection and Protection System





### ◇ IDS：Instrusion Detection System

Dos攻撃を防ぐ。



### ◇ WAF：Web Application Firewall

スクリプト攻撃（クロスサイトスクリプティング、OSコマンドインジェクション、ディレクトリトラバーサル）を防ぐ。




# 12-03. パケット交換方式データ通信の全体

### ◇ TCP/IP階層モデル

パケット交換方式によるデータ通信では、4つの階層を通過する必要がある。この4つの階層は『TCP/IP階層モデル』といい、ヘッダ情報が追加される。TCP/IPモデルで用いられるプロトコルのうち、最も代表的な「TCP」と「IP」から名前をとって「TCP/IP」と名付けられた。

![TCP_IPとは](C:\Projects\Summary_Notes\まとめノート\画像\TCP_IPとは.png)



### ◇ TCP/IP階層モデルを用いたデータ通信の例

1. PC-Aは、構成したIPパケットをEthernetに乗せて、ルータAに送信。
2. ルータAは、IPパケットをデジタル専用線に乗せて、ルータBに送信。
3. ルータBは、構成したIPパケットをEthernetに乗せて、Webサーバに送信。

![ネットワークにおけるTCP_IPを用いたデータ通信](C:\Projects\Summary_Notes\まとめノート\画像\ネットワークにおけるTCP_IPを用いたデータ通信.png)



### ◇ OSI参照モデル

TCP/IPの方がより良いモデルのため、OSI参照モデルに準拠した製品はほとんど無い。

![OSI参照モデル](C:\Projects\Summary_Notes\まとめノート\画像\OSI参照モデル.png)



### ◇ TCP/IP階層モデルとOSI参照モデルの対応関係

TCP/IP階層モデルのネットワークインターフェイス層と、OSI参照モデルのネットワーク層を混合しないように注意せよ。

![TCPIP階層モデルとOSI参照モデルの対応関係](C:\Projects\Summary_Notes\まとめノート\画像\TCPIP階層モデルとOSI参照モデルの対応関係.png)



# 12-04. アプリケーション層の『HTTP』

### ◇ WebAPIの種類

HTTPの構造は、WebAPIの種類によって決まる。WebAPIには、『SOAP』と『REST』がある。

![SOAP API vs REST API](https://user-images.githubusercontent.com/42175286/59290202-fa205100-8cb2-11e9-9a16-8613a88403b4.png)



### ◇ SOAPにおけるメソッド

1999年にMicrosoft社などによって発表された。2000年前半には企業システムのWebサービス化とともに普及するかに思われたが、複雑な構造であったため次第に敬遠されるようになった。その後、簡単な構造のREST APIが好まれるようになった。

**【具体例】**POSTメソッドによるリクエスト

![SOAP API](https://user-images.githubusercontent.com/42175286/59289616-6b5f0480-8cb1-11e9-987f-b1761c73fcf1.gif)



### ◇ RESTにおけるメソッド

![HTTPリクエストのメソッド](https://user-images.githubusercontent.com/42175286/56901644-9875a000-6ad3-11e9-93a1-a738b2e382ac.png)

- **GETメソッドによるリクエスト**  
  URL以降に、『/？～』付加してHTTPリクエストを送る方法。URLに情報が記述されるため、履歴で確認できてしまう。

![GET送信時のHTTPリクエスト](https://user-images.githubusercontent.com/42175286/58061886-0ed95f80-7bb3-11e9-8998-f105a5e0ed40.png)

1. リクエスト行：常に１行
2. ヘッダー：リクエストの詳細情報
3. メソッド：GET
4. リクエストの対象:ジャンプするURLを指定
5. HTTPのバージョン
6. User-Agent：ブラウザのバージョン情報等
7. Accept：ブラウザが想定する(利用可能な)MIMEのタイプ
8. Referer：遷移元のページ
9. Accept-Encoding：ブラウザがデコードできるエンコーディング形式
10. Accept-Language：ブラウザが想定する(利用可能な)言語

- **POSTメソッドによるリクエスト**  
  メッセージボディに記述してHTTPリクエストを送る方法。メッセージボディに情報が記述されるため、履歴では確認できない。
  ![POST送信時のHTTPリクエスト](https://user-images.githubusercontent.com/42175286/58061918-29abd400-7bb3-11e9-94d0-fd528901ba7c.png)

1. リクエスト行：常に１行
2. ヘッダー：リクエストの詳細情報がある
3. 空白行：ヘッダーとボディを分ける
4. ボディ：画面での入力内容が入っている
5. メソッド：POST
6. リクエストの対象：ジャンプするURLを指定
7. HTTPのバージョン

- **レスポンス** 

![HTTPリクエストに対するHTTPレスポンス](https://user-images.githubusercontent.com/42175286/58062092-fd448780-7bb3-11e9-8b33-e11595c4e1fc.PNG)

1. ステータス行：常に１行

2. ヘッダー：レスポンスの詳細情報がある

3. 空白行：ヘッダーとボディを分ける

4. ボディ：HTMLや画像等が入る

5. HTTPのバージョン

6. ステータスコード：200はサーバーのWebシステム処理が成功したことを表す

7. Server：サーバーの名前とバージョン等です。

8. Content-Type：出力するMIMEタイプ

   

### ◇ ステータスコード

- 100番台 継続
- 200番台 リクエスト完了
- 300番台 リダイレクト（移行）
- 400番台 リクエスト失敗
- 500番台 サーバーエラー



# 12-05. アプリケーション層の『SMTP』『POP』

### ◇ メール送信プロトコル

- **SMTP-AUTH**

  メール送信にあたってユーザ認証の仕組みがないSMTPを拡張し、ユーザ認証機能を追加した仕様

- **S/MIME：Secure MIME**

  公開鍵暗号技術を使用して認証、改ざん検出、暗号化などの機能を電子メールソフトに提供する



### ◇ メール受信プロトコル

- **APOP：Authenticated POP**

  メール受信の際に、チャレンジレスポンス方式の認証を行うことで平文の認証情報がネットワークに流れるのを防止するプロトコル

- **POP3：POP3 over TLS**

  TLSのセキュアな通信路上でメールソフトからメールサーバ間のPOP通信を行うプロトコル



# 12-06. トランスポート層の『TCP』

![リクエストとレスポンスにおけるポート番号](C:\Projects\Summary_Notes\まとめノート\画像\リクエストとレスポンスにおけるポート番号.jpg)

### ◇ レスポンスにおけるポート番号の識別の仕組み

![トランスポート層からアプリケーション層へのパケットの移動](C:\Projects\Summary_Notes\まとめノート\画像\トランスポート層からアプリケーション層へのパケットの移動.PNG)

まず、プライベートIPアドレスを用いて、レスポンス先のパソコンを識別する。その後、リクエスト時のポート番号を元にして、特定のアプリにレスポンスする。

**【具体例】**Webページを見ながらメールアプリを起動している場合…

1. プロトコル『POP3』とポート番号『110』を指定して、メールアプリにレスポンス。

2. プロトコル『HTTP』とポート番号『80』を指定して、Webフロントにレスポンス。

3. プロトコル『DNS』とポート番号『53』を指定して、Webフロントにレスポンス。

   

![ポート番号](C:\Projects\Summary_Notes\まとめノート\画像\ポート番号.png)



### ◇ ポートスキャナ

ポートスキャナを用いることによって、各ポートにアクセスし、応答があるかどうかや、どのようなソフトウェアが応答するかを調べ、一覧表示することができる。



### ◇ ポート番号の種類

アプリには、種類ごとにポート番号が割り当てられている。

- **Well known ポート番号（0 ～ 1023）**

  IANA：Internet Assigned Numbers Authority（インターネット割当番号公社）によって管理されているポート番号。Webサーバがリクエストを受信する時、またレスポンスを送信する時に使用される。

  ![ポート番号とプロトコルの対応関係](C:\Projects\Summary_Notes\まとめノート\画像\ポート番号とプロトコルの対応関係.png)

- **登録済みポート番号（1024 ～ 49151）**

  IANAが登録申請を受けて公開しているポート番号。企業が作成した独自のアプリなどに対して割り当てられる。クライアントがリクエストを送信する時、またレスポンスを受信する時に使用される。

- **動的／非公式ポート番号（49152 ～ 65535）**

  自由に使用できるポート番号。クライアントがリクエストを送信する時、またレスポンスを受信する時に使用される。



# 12-07. インターネット層の『IPv4』

### ◇ IPv4アドレスの種類

![プライベートIPアドレスとグローバルIPアドレス](C:\Projects\Summary_Notes\まとめノート\画像\プライベートIPアドレスとグローバルIPアドレス.png)

- **プライベートIPアドレス**

  LAN内で使用される。異なるプライベートネットワーク間では、同じIPv4アドレスが存在する。プライベートｆは、『10.0.0.0 ～ 10.255.255.255』、『172.16.0.0 ～ 172.31.255.255』、『192.168.0.0 ～ 192.168.255.255』で表される。

- **グローバルIPアドレス**

  プロバイダが提供するIPv4アドレス。パブリックネットワーク内に同じIPv4アドレスは存在せず、Network Information Centerへの使用申請が必要。プライベートIPアドレスの番号でなければ、グローバルIPアドレスである。
  
  

### ◇ IPv4アドレスのクラス

**【具体例】**128.0.0.0は、クラス B

- **クラスA**
  上位8ビット部分が、10進表記で、0～127
- **クラスB**
  上位8ビット部分が、10進表記で、128～191
- **クラスC**
  上位8ビット部分が、10進表記で、192～223
- **クラスD**
  上位8ビット部分が、10進表記で、224～239

  

### ◇ URLとメールアドレスの構造

- **各部品の名称**

![URLと電子メールの構造](C:\Projects\Summary_Notes\まとめノート\画像\URLと電子メールの構造.png)

- **各部品の様々な組み合わせ**

![ホスト名とドメイン名の組み合わせの種類](C:\Projects\Summary_Notes\まとめノート\画像\ホスト名とドメイン名の組み合わせの種類.gif)



### ◇ 完全修飾ドメイン名とグローバルIPアドレスのマッピング

![IPアドレスと完全修飾ドメイン名のマッピング1（編集後）](C:\Projects\Summary_Notes\まとめノート\画像\IPアドレスと完全修飾ドメイン名のマッピング4.png)

例えば、外部WebサーバのグローバルIPアドレスが『203.142.205.139』であると知っている場合、URLのプロトコル部分以下を『203.142.205.139』としてリクエストすれば、外部Webサーバが提供するウェブサイトにアクセスできる。しかし、グローバルIPアドレスは数字の羅列であるため、人間には覚えにくい。そこで、グローバルIPアドレスの代わりに、完全修飾ドメイン名をURLの一部として用いる。





# 12-08. 異なるネットワーク間でのデータ変換

### ◇ NAT：Network Address TranslationによるIPアドレスv4の変換

プライベートIPアドレスとグローバルIPアドレスを相互変換する機能。

![nat 変換](C:\Projects\Summary_Notes\まとめノート\画像\nat 変換.png)



### ◇ NAPT：Network Address Port Translationによるポート番号の変換

NATと同様にプライベートIPアドレスとグローバルIPアドレスの間を相互変換するだけでなく、ポート番号も変換する。

![napt変換](C:\Projects\Summary_Notes\まとめノート\画像\napt変換.png)



# 12-09. Proxyサーバ、DNSサーバ、Webサーバ、NAT、でのデータ通信まとめ

![ホスト名とIPアドレスの変換](C:\Projects\Summary_Notes\まとめノート\画像\IPアドレスと完全修飾ドメイン名のマッピング3.png)

1. クライアントPCは、完全修飾ドメイン名を、フォワードProxyサーバにリクエスト。

2. DNSキャッシュサーバは、完全修飾ドメイン名を、リバースProxyサーバにリクエスト。

3. リバースProxyサーバは、完全修飾ドメイン名を、DNSサーバにリクエスト。

4. DNSサーバは、完全修飾ドメインにマッピングされるIPv4アドレスを取得し、リバースProxyサーバにレスポンス。

5. リバースProxyサーバは、IPv4アドレスを、フォワードProxyサーバにレスポンス。

   （※NATによるIPv4アドレスのネットワーク間変換が起こる）

6. フォワードProxyサーバは、IPv4アドレスを、クライアントPCにレスポンス。

7. クライアントPCは、レスポンスされたIPv4アドレスを基に、Webページを、リバースProxyサーバにリクエスト。

8. リバースProxyサーバは、Webページを、Webサーバにリクエスト。

9. Webサーバは、Webページを、リバースProxyサーバにレスポンス。

10. リバースProxyサーバは、Webページを、クライアントPCにレスポンス。

※上記の様に、リクエストとレスポンスが繰り返されるが、データ通信は光速なので、１秒もかからない。

```

```