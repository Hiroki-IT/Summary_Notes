# 勉強の方針

1. 必ず、実例として、それが扱われているのかを覚えること。
2. 必ず、言葉ではなく、イラストを用いて覚えること。
3. 必ず、知識の『点』と『点』を繋ぎ、『線』にしろ
4. 必ず、まとめることでインプットしているだけなので、口頭で説明してアプトプットしろ。
5. キタミ式で大枠をとらえて、過去問で肉付けしていく。



# 16-01. システムの設計方法の歴史

### ◇ システム実装のための設計方法の種類と歴史

![構造化プログラミングからオブジェクト指向へ](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\構造化プログラミングからオブジェクト指向へ.png)



# 16-02. オブジェクトモデリングの図式化方法

### ◇  オブジェクトモデリングの図式化方法の種類

![複数視点のモデル化とUML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\複数視点のモデル化とUML.jpg)



### ◇ UML：Unified Modeling Language（統一モデリング言語）

オブジェクト指向プログラミング型のシステム設計を行うには、まず、オブジェクトモデリングを行う必要がある。オブジェクトモデリングをダイアグラム図を用いて解りやすく視覚化する表記方法を Unified Modeling Language という。UMLにおけるダイアグラム図は、構造の視点に基づく構造図と、振舞の視点に基づく振舞図に分類される。

（※ちなみ、UMLは、システム設計だけでなく、データベース設計にも使える）

![UML-0](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\UML-0.png)

### ◇ UMLのダイアグラム一覧

![UML-1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\UML-1.png)

![UML-2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\UML-2.png)



# 16-03. UMLの構造図：『構造』の視点

### ◇  オブジェクトモデリングの図式化方法の種類（再掲）

![複数視点のモデル化とUML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\複数視点のモデル化とUML.jpg)

![UML-1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\UML-1.png)



### ◇ クラス図

クラスの構造、クラス間の関係、役割を表記する方法。

![クラス図の線の種類](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クラス図の線の種類.png)

- **Class**

１つのクラスを、クラス区画、属性区画、操作区画の３要素で表記する方法。

![UML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クラス図.png)

- **Association（関連）**

２つのクラスを関連させる場合、クラスを線で繋ぐことで関連性を表記する方法。クラス図の実装の章を参照せよ。

![クラス図の関連表現](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クラス図の関連表現.png)

- **Aggregation（集約）**

  クラスと別のクラスが、全体と部分の関係であることを表記する方法。クラス図の実装の章を参照せよ。

  （例）社員は１つの会社に所属する場合

    「社員」から見た「会社」は1つである。逆に、「会社」からみた「社員」は0人以上であることを表現。

![集約](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\集約.png)



- **Composition（合成）**

  クラス図の実装の章を参照せよ。

- **Dependency（依存）**

  

- **Realization（実現）＝ 抽象オブジェクト**

  クラス図の実装の章を参照せよ。

- **Generalization（凡化）**

  クラス間で属性、操作、関連を引継ぐことを表記する方法。サブクラスから見たスーパークラスとの関係を『汎化』、逆にスーパークラスから見たサブクラスとの関係を『特化』という。プログラミングにおける『継承』は、特化を実装する方法の一つ。

![汎化と特化](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\汎化と特化.png)

- **Cardinality（多重度）**

  クラスと別のクラスが、何個と何個で関係しているかを表記する方法。

  （例）社員は１つの会社にしか所属できない場合

  「社員」から見た「会社」は1つである。逆に、「会社」からみた「社員」は0人以上であるという表記。

![多重度](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\多重度.png)

![多重度一覧](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\多重度の表記方法.png)



# 16-04. UMLの構造図の実装方法

クラス図のAssociation、Aggregation、Compositionでは、実装されたオブジェクト間の依存度に違いがある。

![Association, Aggregation, Compositionの関係の強さの違い](https://user-images.githubusercontent.com/42175286/59730918-1efe6080-927f-11e9-85ba-51d3054a7a24.png)



### ◇ Association（関連）



### ◇ Aggregation（集約）

【Tireクラス】

```
class Tire {}
```

【CarXクラス】

```
//CarXクラス定義
class CarX  
{
    //CarXクラスがタイヤクラスを引数として扱えるように設定
    public function __construct(Tire $t1, Tire $2, Tire $t3, Tire $t4)
    {
        $this->tire1 = $t1;
        $this->tire2 = $t2;
        $this->tire3 = $t3;
        $this->tire4 = $t4;
    }
}
```

【CarYクラス】

```
//CarYクラス定義
class CarY  
{
    //CarYクラスがタイヤクラスを引数として扱えるように設定
    public function __construct(Tire $t1, Tire $2, Tire $t3, Tire $t4)
    {
        //引数のTireクラスからプロパティにアクセス
        $this->tire1 = $t1;
        $this->tire2 = $t2;
        $this->tire3 = $t3;
        $this->tire4 = $t4;
    }
}
```

以下の様に、Tireクラスのインスタンスを、CarXクラスとCarYクラスの引数として用いている。
Tireクラスの各インスタンスと、2つのCarクラスの双方向で、依存関係はない。

```
//Tireクラスをインスタンス化
$tire1 = new Tire();
$tire2 = new Tire();
$tire3 = new Tire();
$tire4 = new Tire();
$tire5 = new Tire();
$tire6 = new Tire();

//Tireクラスのインスタンスを引数として扱う
$suv = new CarX($tire1, $tire2, $tire3, $tire4);

//Tireクラスのインスタンスを引数として扱う
$suv = new CarY($tire1, $tire2, $tire5, $tire6);
```



### ◇ Composition（合成）

【Lockクラス】

```
//Lockクラス定義
class Lock {}
```

【Keyクラス】

```
//Keyクラス定義
class Key {

    public function __construct(){
    
    }
}
```

【Carクラス】

```
//Carクラスを定義
class Car  
{
    
    public function __construct()
    {
        //引数Lockクラスをインスタンス化
        $lock = new Lock();
    }
}
```

以下の様に、LockクラスのLockインスタンスは、Carクラスの中で定義されているため、Lockインスタンスにはアクセスできない。また、Carクラスが起動しなければ、Lockインスタンスは起動できない。このように、LockインスタンスからCarクラスの方向には、強い依存関係がある。

```
//エラーになる。$lockには直接アクセスできない。
$key = new Key($lock);
```



### ◇ Realization（実現）

Realizationの実装は、すなわち抽象オブジェクトの継承である。例えば、以下の条件の社員オブジェクトを実装したいとする。

1. 午前９時に出社
2. 営業部・開発部・総務部があり、それぞれが異なる仕事を行う
3. 午後６時に退社

この時、『働くメソッド』は部署ごとに異なってしまうが、どう実装したら良いのか…

![抽象クラスと抽象メソッド-1](https://user-images.githubusercontent.com/42175286/59590447-12ff8b00-9127-11e9-802e-126279fcb0b1.PNG)

これを解決するために、例えば、次の２つが実装方法が考えられる。

- 営業部社員オブジェクト、開発部社員オブジェクト、総務部社員オブジェクトを別々に実装  
  メリット：同じ部署の他のオブジェクトに影響を与えられる。  
  デメリット：各社員オブジェクトで共通の処理を個別に実装しなければならない。共通の処理が同じコードで書かれる保証がない。
- 一つの社員オブジェクトの中で、働くメソッドに部署ごとで変化する引数を設定  
  メリット：全部署の社員を一つのオブジェクトで呼び出せる。  
  デメリット：一つの修正が、全部署の社員の処理に影響を与えてしまう。

抽象オブジェクトと抽象メソッドを用いると、2つのメリットを生かしつつ、デメリットを解消可能。

※オーバーライドは、メソッドの再定義による上書きであり、一方で抽象オブジェクトの継承は、抽象メソッドの実装である。

![抽象クラスと抽象メソッド-2](https://user-images.githubusercontent.com/42175286/59590387-e8adcd80-9126-11e9-87b3-7659468af2f6.PNG)



# 16-05. 概念データモデリング

### ◇  オブジェクトモデリングの図式化方法の種類（再掲）

![複数視点のモデル化とUML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\複数視点のモデル化とUML.jpg)



### ◇ ER図：Entity Relation Diagram

データベースの設計において、エンティティ間の関係を表すために用いられるダイアグラム図。『IE 記法』と『IDEF1X 記法』が一般的に用いられる。

![ER図（IE記法）](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ER図（IE記法）.png)

- **Entity と Attribute**

  ![エンティティとアトリビュート](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\エンティティとアトリビュート.png)

- **Relation と Cardinality（多重度）**

  エンティティ間の関係を表す。

  ![リレーションとカーディナリティ](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\リレーションとカーディナリティ.png)

- **1：1**

  ![１：１](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\１：１.png)

- **1：多（Relation が曖昧な状態）**

  設計が進むにつれ、「1：0 以上の関係」「1：1 以上の関係」のように具体化しく。

  ![１：多（Relationが曖昧な状態）](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\１：多（Relationが曖昧な状態）.png)

- **1：1 以上**

  ![１：１以上](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\１：１以上.png)



# 16-06. UMLの振舞図：『機能』の視点

### ◇  オブジェクトモデリングの図式化方法の種類（再掲）

![複数視点のモデル化とUML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\複数視点のモデル化とUML.jpg)

![UML-2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\UML-2.png)



### ◇ Use case 図（使用事例図）

ユーザーの視点で、システムの利用例を表記する方法。

**【設計例】**

![ユースケース図](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ユースケース図.png)



### ◇  アクティビティ図

ビジネスロジックや業務フローを手続き的に表記する方法。

**【設計例】**

![アクティビティ図](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\アクティビティ図.png)

- **アルゴリズムとフローチャート**

  ![p549-1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\p549-1.gif)

  ![p549-2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\p549-2.gif)

  ![p549-3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\p549-3.gif)





# 16-07. 構造化分析・設計

### ◇  オブジェクトモデリングの図式化方法の種類（再掲）

![複数視点のモデル化とUML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\複数視点のモデル化とUML.jpg)



### ◇ DFD：Data Flow Diagram（データフロー図）

![データフロー図](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\データフロー図.jpg)



# 16-08. UMLの振舞図：『振舞』の視点

### ◇  シーケンス図

オブジェクトからオブジェクトへの振舞の流れを、時間軸に沿って表記する方法。Alfortの設計ではこれが用いられた。

**【設計例】**

1. 店員は在庫管理画面から在庫一覧を確認可能。
2. この機能は、『店員オブジェクト』、『管理画面オブジェクト』、『倉庫オブジェクト』、『商品オブジェクト』から構成されている。

![シーケンス図](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\シーケンス図.png)



# 16-09. リアルタイム構造化・分析

### ◇  オブジェクトモデリングの図式化方法の種類（再掲）

![複数視点のモデル化とUML](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\複数視点のモデル化とUML.jpg)



### ◇ 状態遷移図

「状態」を丸，「⁠遷移」を矢印で表す。矢印の横の説明は、遷移のきっかけとなる「イベント（入力）⁠／アクション（出力）⁠」を示す。

![状態遷移図](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ストップウォッチ状態遷移図.jpg)



### ◇ 状態遷移表

状態遷移表を作成してみると，状態遷移図では、9つあるセルのうち4つのセルしか表現できておらず，残り5つのセルは表現されていないことに気づくことができる。

![状態遷移表](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ストップウォッチ状態遷移表.jpg)

- **（例題）12.2 という状態**

1. 初期の状態を『a』として、最初が数字なので、a行の『b』へ移動。
2. 現在の状態『b』から、次は数字なので、b行の『b』へ移動。
3. 現在の状態『b』から、次は小数点なので、b行の『d』へ移動
4. 現在の状態『d』から、次は数字なので、b行の『e』へ移動

![状態遷移表](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\状態遷移表.png)



# 16-10. よく用いられるデータ型の構造

プログラムを書く際にはどのような処理を行うのかを事前に考え、その処理にとって最適なデータ構造で記述する必要がある。そのためにも、それぞれのデータ構造の特徴（長所、短所）を知っておくことが重要である。



### ◇ Array型

- **多次元配列**

  中に配列をもつ配列のこと。配列の入れ子構造が２段の場合、『二次元配列』と呼ぶ。

```
Array
(
    [0] => Array
        (
            [0] => リンゴ
            [1] => イチゴ
            [2] => トマト
        )

    [1] => Array
        (
            [0] => メロン
            [1] => キュウリ
            [2] => ピーマン
        )

    [2] => Array
        (
            [0] => バナナ
            [1] => パイナップル
            [2] => レモン
        )
)
```

- **連想配列**

  中に配列をもち、キーに名前がついている（赤、緑、黄、果物、野菜）ような配列のこと。下の例は、二次元配列かつ連想配列である。

```
Array
(
    [赤] => Array
        (
            [果物] => リンゴ
            [果物] => イチゴ
            [野菜] => トマト
        )

    [緑] => Array
        (
            [果物] => メロン
            [野菜] => キュウリ
            [野菜] => ピーマン
        )

    [黄] => Array
        (
            [果物] => バナナ
            [果物] => パイナップル
            [果物] => レモン
        )
)
```



### ◇ List型

ポインタは、次のデータがどこにあるかのアドレスを表す。

- **単方向リスト**

![p555-1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\p555-1.gif)

- **双方向リスト**

![p555-2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\p555-2.gif)

- **循環リスト**

![p555-3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\p555-3.gif)



### ◇ Queue型

phpでは、```array_push()```と```array_shift()```で実装可能。

![Queue1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Queue1.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

 

![Queue2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Queue2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

 

![Queue3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Queue3.gif)



### ◇ Stack

phpでは、```array_push()```と```array_pop()```で実装可能。

![Stack1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Stack1.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

 

![Stack2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Stack2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

 

![Stack3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Stack3.gif)

### ◇ ツリー構造

- **二分探索木**

  各ノードにデータが格納されている。

![二分探索木](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索木1.gif)



- **ヒープ**

  Priority Queueを実現するときに用いられる。各ノードにデータが格納されている。

  ![ヒープ1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ヒープ1.gif)

  ![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![ヒープ1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ヒープ2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![ヒープ2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ヒープ3.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![ヒープ3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ヒープ4.gif)



# 16-11. データ整列アルゴリズム

例えば、次のような表では、どのような仕組みで「昇順」「降順」への並び替えが行われるのだろうか。

![ソートの仕組み](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ソートの仕組み.gif)



### ◇ 基本交換法（バブルソート）

隣り合ったデータの比較と入替えを繰り返すことによって，小さな値のデータを次第に端のほうに移していく方法。

![バブルソート1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\バブルソート1.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![バブルソート2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\バブルソート2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

 

![バブルソート3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\バブルソート3.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![バブルソート4](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\バブルソート4.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![バブルソート5](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\バブルソート5.gif)



![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

 



![バブルソート6](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\バブルソート6.gif)



### ◇ 基本選択法（選択ソート）

データ中の最小値を求め，次にそれを除いた部分の中から最小値を求める。この操作を繰り返していく方法。

![選択ソート1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\選択ソート1.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![選択ソート2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\選択ソート2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![選択ソート3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\選択ソート3.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![選択ソート4](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\選択ソート4.gif)

### ◇ 基本挿入法（挿入ソート）

既に整列済みのデータ列の正しい位置に，データを追加する操作を繰り返していく方法。

### ◇ ヒープソート



### ◇ シェルソート



### ◇ クイックソート

適当な基準値を選び，それより小さな値のグループと大きな値のグループにデータを分割する。同様にして，グループの中で基準値を選び，それぞれのグループを分割する。この操作を繰り返していく方法。

![クイックソート-1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-1.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-2.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-3.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-4](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-4.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-5](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-5.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-6](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-6.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-7](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-7.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-8](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-8.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-9](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-9.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-10](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-10.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-11](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-11.JPG)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![クイックソート-12](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\クイックソート-12.JPG)



# 16-12. データ探索アルゴリズム

### ◇ 線形探索法

  今回は「６」を探す。

![線形探索法1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\線形探索法1.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![線形探索法2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\線形探索法2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![線形探索法3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\線形探索法3.gif)

### ◇ 二分探索法

  前提として、ソートによって、すでにデータが整列させられているとする。今回は「６」を探す。

![二分探索法1](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索法1.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![二分探索法2](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索法2.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![二分探索法3](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索法3.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![二分探索法4](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索法4.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![二分探索法5](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索法5.gif)

![矢印_80x82](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\矢印_80x82.jpg)

![二分探索法6](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\二分探索法6.gif)

### ◇ ハッシュ法









# 16-13.   『Java』 について

### ◇ Javaで書かれているプログラム

- **Java Applet**

Javaで書かれたWebのフロントエンドで動くプログラム。Java9より非推奨になり、Java 11で廃止。

![Java Applet](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Java Applet.gif)



- **Java Servlet**

Javaで書かれたWebのサーバーエンドで動くプログラム。

![Java Servlet](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\Java Servlet.gif)



### ◇ Garbage collection

Javaでは、Javaオブジェクトに対するメモリ領域の割り当てや解放をJVM（Java仮想マシン）が自動的に行う。この自動解放メカニズムを『Garbage collection』という。



# 16-14. ソースコードの機械語変換

### ◇ Compier言語とInterpreter言語の種類

ソースコード（ウェブサイトならJava、php、Javascriptなど）は、機械語に変換された後、CPUによって読み込まれる。そして、ハードウェア（ウェブサイトならパソコン）のCPUによって、ソースコードに書かれた様々な処理が実行される。

![コンパイル型とインタプリタ型言語](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\コンパイル型とインタプリタ型言語.jpg)

### ◇ ビルド

Compier言語やInterpreter言語では、ソースコードは機械語からなるオブジェクトコードに変換される（インタプリタ言語であっても、このプロセスはコンパイルと言うらしい…）。コンパイル後に、各オブジェクトコードは、ライブラリにリンクされる。この一連のプロセスを『ビルド』という。

※Vue.jsを使用するためには『asset:build』や『asset:watch』が必要であるが、まさにこのため。

![ビルドとコンパイル](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\ビルドとコンパイル.jpg)



### ◇ Compiler言語について

コードをまとめて機械語に変換し、バイナリ形式のオブジェクトコードを生成する。そのファイルを実行する。

（例）C#

![コンパイラ言語](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\コンパイラ言語.png)

- **コンパイルの詳しい流れ**

![字句解析、構文解析、意味解析、最適化](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\字句解析、構文解析、意味解析、最適化.png)

1. Lexical analysis（字句解析）

   ソースコードの文字列を言語の最小単位（トークン）の列に分解。

2. Syntax analysis（構文解析）

   トークンの列をツリー構造に変換。

3. Semantics analysis（意味解析）

   ツリー構造を基に、ソースコードに論理的な誤りがないか解析。

4. Code optimization（コード最適化）

   ソースコードの冗長な部分を削除または編集。機械語をより短くするこができる。

5. Code generation（コード生成）

   最適化されたコードをバイナリ形式のオブジェクトコードに変換。

6. 処理の実行

   オブジェクトコードを基に、処理が実行される。



### ◇ Interpreter言語について

コードを一行ずつ機械語に変換し、順次実行する言語。

（例）Java（※他とはプロセスが異なる中間型）、PHP、Ruby、JavaScript、Python

![インタプリタ言語](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\インタプリタ言語.png)

- **コンパイルの詳しい流れ**

![字句解析、構文解析、意味解析、最適化](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\字句解析、構文解析、意味解析、最適化.png)

1. Lexical analysis（字句解析）

   ソースコードの文字列を言語の最小単位（トークン）の列に分解。

2. Syntax analysis（構文解析）

   トークンの列をツリー構造に変換。ソースコードから構造体を構築することを構文解析といい、Htmlを構文解析してDOMツリーを構築する処理とは別物なので注意。

3. Semantics analysis（意味解析）

   ツリー構造を基に、ソースコードに論理的な誤りがないか解析。

4. 処理の実行

   意味解析の結果を基に、処理が実行される。



# 16-15.  TRUE vs. FALSE

### ◇ FALSE の定義

- **表示なし**

- **キーワード FALSE false**

- **整数 0**

- **浮動小数点 0.0**

- **空の文字列 " "**

- **空の文字列 ' '**

- **文字列 "0"（文字列としての0）**

- **要素数が 0 の配列$ary = array();**

- **プロパティーやメソッドを含まない空のオブジェクト**

- **NULL値**

  

### ◇ TRUE の定義

上記の値以外は、全て TRUE



### ◇ 変数に値が入っているのかを確かめるシリーズ

![値が存在するのかを確かめる](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\値が存在するのかを確かめる.jpg)

```
# 右辺には、上記に当てはまらない状態『TRUE』が置かれている。
if($this->$var == TRUE){
	処理A;
}

# ただし、基本的に右辺は省略すべき。

if($this->$var){
	処理A;
}
```



# 16-16. メソッドの作り方

### ◇ 引数の渡し方

- **参照渡し**

「参照渡し」とは、変数に代入した値の参照先（メモリアドレス）を渡すこと。

```
$value = 1;
$result =& $value; // 値の入れ物を参照先として代入
```

（例）```$b```には、```$a```の参照によって10が格納される。

```
$a = 2;
$b =& $a;  // 変数aを&をつけて代入
$a = 10;    // 変数aの値を変更
echo $b;

# 結果
10
```

- **値渡し**

「値渡し」とは、変数に代入した値のコピーを渡すこと。

```
$value = 1;
$result = $value; // 1をコピーして代入
```

（例）```$b```には、```$a```の一行目の格納によって2が格納される。

```
$a = 2;
$b = $a;  // 変数aを代入
$a = 10;  // 変数aの値を変更
echo $b;

# 結果
2
```



### ◇ **Recursive call：再帰的プログラム**

自プログラムから、自身自身を呼び出して実行できるプログラムのこと。

（例）ある関数 ``` f  ```の定義の中に ``` f ```自身を呼び出している箇所がある。

![再帰的](D:\Documents\Drive 1st\プログラミング自習\まとめノート\画像\再帰的.png)



